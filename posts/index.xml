<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Leon Li's blog</title><link>https://ileonli.github.io/posts/</link><description>Recent content in Posts on Leon Li's blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Wed, 15 Jan 2025 21:11:26 +0800</lastBuildDate><atom:link href="https://ileonli.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 模块化</title><link>https://ileonli.github.io/posts/java/module/</link><pubDate>Wed, 15 Jan 2025 21:11:26 +0800</pubDate><guid>https://ileonli.github.io/posts/java/module/</guid><description>&lt;h1 id="java-模块化翻译">Java 模块化（翻译）&lt;/h1>
&lt;blockquote>
&lt;p>本文翻译自：https://www.oracle.com/corporate/features/understanding-java-9-modules.html&lt;/p>&lt;/blockquote>
&lt;p>在本文中，我将介绍 Java 9 平台模块系统（JPMS），这是自 Java 诞生以来最重要的新软件工程技术。模块化（即 &lt;a href="http://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener noreferrer">Jigsaw 项目&lt;/a> 的成果）有助于各级开发人员在构建、维护和发展软件系统，特别是大型系统时，提高生产力。&lt;/p>
&lt;h2 id="什么是模块化">什么是模块化&lt;/h2>
&lt;p>模块化在包的基础上增加了一个更高层次的聚合。关键的新语言元素是模块（一个唯一命名且可重用的相关包的组合，以及资源（如图像和 XML 文件））和一个模块描述符，用于指定以下内容：&lt;/p>
&lt;ul>
&lt;li>模块的名称&lt;/li>
&lt;li>模块的依赖关系（即该模块所依赖的其它模块）&lt;/li>
&lt;li>它显式提供给其它模块使用的包（默认情况下，其它模块的不可使用非显示提供的包）&lt;/li>
&lt;li>它提供的服务&lt;/li>
&lt;li>它使用的服务&lt;/li>
&lt;li>允许哪些模块进行反射访问&lt;/li>
&lt;/ul>
&lt;h2 id="历史">历史&lt;/h2>
&lt;p>Java SE 自 1995 年问世以来，已有大约 1000 万开发者使用它来构建从资源受限设备（如物联网（IoT）和其它嵌入式设备）的小型应用程序，到大规模的关键业务和关键任务系统。尽管存在大量的遗留代码，但迄今为止，Java 主要是一个一体化的通用解决方案。多年来，人们进行了各种模块化 Java 的努力，不仅没有一个被广泛使用，而且也没有一个能够用于模块化 Java 平台的实现。&lt;/p>
&lt;p>Java SE 平台的模块化实现一直充满挑战，这一努力花费了许多年时间。&lt;a href="https://jcp.org/en/jsr/detail?id=277" target="_blank" rel="noopener noreferrer">JSR 277: Java Module System&lt;/a> 最初于 2005 年针对 Java 7 提出。随后，该 JSR 被 &lt;a href="https://jcp.org/en/jsr/detail?id=376" target="_blank" rel="noopener noreferrer">JSR 376: Java Platform Module System&lt;/a> 取代，并计划用于 Java 8。最终，Java SE 平台在 Java 9 中实现了模块化，但这一过程导致 Java 9 的发布被推迟至 2017 年 9 月。&lt;/p></description></item><item><title>Java AQS（翻译）</title><link>https://ileonli.github.io/posts/java/abstractqueuedsynchronizer/</link><pubDate>Sun, 08 Dec 2024 17:33:01 +0800</pubDate><guid>https://ileonli.github.io/posts/java/abstractqueuedsynchronizer/</guid><description>&lt;h1 id="java-aqs翻译">Java AQS（翻译）&lt;/h1>
&lt;blockquote>
&lt;p>本文是 Doug Lea 的 &lt;em>The java.util.concurrent Synchronizer Framework&lt;/em> 一文的翻译，该论文描述了 &lt;code>AbstractQueuedSynchronizer&lt;/code> 类的基本原理、设计、实现、使用和性能。&lt;/p>
&lt;p>论文地址：https://gee.cs.oswego.edu/dl/papers/aqs.pdf&lt;/p>&lt;/blockquote>
&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>J2SE 1.5 版本的 &lt;code>java.util.concurrent&lt;/code> 包中的大多数同步器（如：锁、屏障等）都是基于 &lt;code>AbstractQueuedSynchronizer&lt;/code> 类的构建的框架构建的。该框架提供了常见的机制，用于原子地管理同步状态、阻塞和解除阻塞线程以及队列操作。本文介绍了该框架的基本原理、设计、实现、使用方法和性能。&lt;/p>
&lt;h2 id="引言">引言&lt;/h2>
&lt;p>Java 在发布的 J2SE-1.5 版本中引入了 &lt;code>java.util.concurrent&lt;/code> 包，该包由 JCP 的 &lt;a href="https://gee.cs.oswego.edu/dl/concurrency-interest/jsr166-slides.pdf" target="_blank" rel="noopener noreferrer">JSR 166&lt;/a> 创建的一组并发支持类。其中包括一组同步器抽象数据类型，这些类维护内部同步状态（例如，表示锁是锁定还是解锁），提供更新和检查该状态的操作，并至少包含一个方法，该方法会阻塞调用的线程（如果同步状态要求阻塞），当其它线程更改同步状态以允许线程继续时，调用线程会恢复执行。示例包括各种形式的互斥锁（mutual exclusion locks）、读写锁（read-write locks）、信号量（semaphores）、屏障（barriers）、异步结果（future）、事件指示器（event indicators）和交接队列（handoff queues）。&lt;/p>
&lt;p>众所周知，同步器可以用来实现其它任何的同步器。例如：可以使用可重入锁构建信号量，反之亦然。然而，通过此方式会导致系统较为复杂、开销大及不灵活，只能算是一种二流的工程选择。此外，从概念上来说，此方式也不具吸引力。如果这些结构之间没有比其它更为基础的，那么开发者就不应被迫选择其中一个构建其它的结构。相反，JSR166 构建了一个以 &lt;code>AbstractQueuedSynchronizer&lt;/code> 类为中心的小框架，该框架提供了通用的机制，这些机制被包中的大多数同步器以及用户可能自行定义的类所使用。&lt;/p>
&lt;p>本文的其余部分将讨论该框架的需求、设计和实现的主要思想、示例用法以及一些展示其性能特征的测量结果。&lt;/p>
&lt;h2 id="需求">需求&lt;/h2>
&lt;h3 id="功能">功能&lt;/h3>
&lt;p>同步器有两种方法：至少一个 &lt;code>acquire&lt;/code> 操作，该操作可以阻塞调用线程，除非/直到同步状态允许其执行；至少一个 &lt;code>release&lt;/code> 操作，该操作可以改变同步状态，以便允许一个或多个被阻塞的线程解除阻塞。&lt;/p>
&lt;p>&lt;code>java.util.concurrent&lt;/code> 包没有为同步器定义一个统一的 API。一些类是通过通用的接口定义的（如：&lt;code>Lock&lt;/code>），但其它的仅包含特别的版本。因此，&lt;code>acquire&lt;/code> 和 &lt;code>release&lt;/code> 操作在不同类中使用了不同的名称。例如：&lt;code>Lock.lock&lt;/code>、&lt;code>Semaphore.acquire&lt;/code>、&lt;code>CountDownLatch.await&lt;/code> 和 &lt;code>FutureTask.get&lt;/code> 方法都映射到框架的 &lt;code>acquire&lt;/code> 方法。然而，该包在各个类之间保持一致的约定，以支持一系列常见的使用选项。在有意义的情况下，每个同步器支持：&lt;/p>
&lt;ul>
&lt;li>非阻塞尝试获取同步状态（例如：&lt;code>tryLock&lt;/code>）以及阻塞版本。&lt;/li>
&lt;li>可选的超时，应用程序可放弃等待。&lt;/li>
&lt;li>通过中断实现可取消性，通常分为一个可取消的 &lt;code>acquire&lt;/code> 版本和一个不可取消的版本。&lt;/li>
&lt;/ul>
&lt;p>取决于是否仅管理独占状态，同步器可能有所不同。&lt;strong>独占&lt;/strong>：一次只有一个线程可以继续执行，直到可能的阻塞点；&lt;strong>共享&lt;/strong>：多个线程至少有时可以继续执行。常规的锁需要维护独占状态，但计数信号量可能被多个线程获取，数量由计数值决定。为了广泛使用，该框架必须支持这两种操作模式。&lt;/p>
&lt;p>&lt;code>java.util.concurrent&lt;/code> 包还定义了 &lt;code>Condition&lt;/code> 接口，支持类似 monitor 的 &lt;code>await&lt;/code> 和 &lt;code>signal&lt;/code> 操作，通常与 &lt;code>Lock&lt;/code> 类配合使用。&lt;/p></description></item><item><title>Java 动态代理</title><link>https://ileonli.github.io/posts/java/dynamic-proxy/</link><pubDate>Thu, 05 Dec 2024 21:28:06 +0800</pubDate><guid>https://ileonli.github.io/posts/java/dynamic-proxy/</guid><description>&lt;h1 id="java-动态代理">Java 动态代理&lt;/h1>
&lt;p>在 Java 动态代理机制中，InvocationHandler 接口和 Proxy 类是核心组件，用于在运行时动态创建代理类和代理对象。&lt;/p>
&lt;h2 id="proxy">Proxy&lt;/h2>
&lt;p>&lt;code>Proxy&lt;/code> 类主要使用 &lt;code>newProxyInstance()&lt;/code> 静态方法生成代理对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Object &lt;span style="color:#a6e22e">newProxyInstance&lt;/span>(ClassLoader loader,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;[]&lt;/span> interfaces,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InvocationHandler h) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该方法主要有三个参数：&lt;/p>
&lt;ol>
&lt;li>&lt;code>loader&lt;/code>：定义代理类的类加载器。&lt;/li>
&lt;li>&lt;code>interfaces&lt;/code>：代理类要实现的接口列表。&lt;/li>
&lt;li>&lt;code>h&lt;/code>：用于分发方法调用的调用处理器。&lt;/li>
&lt;/ol>
&lt;h2 id="invocationhandler">InvocationHandler&lt;/h2>
&lt;p>当动态代理对象调用一个方法时，此方法的调用就会被转发到实现 &lt;code>InvocationHandler&lt;/code> 接口类的 &lt;code>invoke&lt;/code> 方法来调用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">InvocationHandler&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">invoke&lt;/span>(Object proxy, Method method, Object&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> Throwable;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该方法主要有三个参数：&lt;/p>
&lt;ol>
&lt;li>&lt;code>proxy&lt;/code>：动态生成的代理类的实例。&lt;/li>
&lt;li>&lt;code>method&lt;/code>：代理类对象调用的方法。&lt;/li>
&lt;li>&lt;code>args&lt;/code>：调用 &lt;code>method&lt;/code> 方法的参数。&lt;/li>
&lt;/ol>
&lt;p>通过 &lt;code>Proxy&lt;/code> 类的 &lt;code>newProxyInstance()&lt;/code> 创建的代理对象在调用方法的时候，实际会调用到实现 &lt;code>InvocationHandler&lt;/code> 接口的类的 &lt;code>invoke()&lt;/code> 方法。&lt;/p>
&lt;h2 id="具体步骤">具体步骤&lt;/h2>
&lt;p>&lt;code>TargetClass&lt;/code> 类继承自 &lt;code>InterfaceA&lt;/code> 和 &lt;code>InterfaceB&lt;/code> 接口。&lt;/p>
&lt;p>如果想在 &lt;code>targetA()&lt;/code> 和 &lt;code>targetB()&lt;/code> 方法调用前后进行一些额外操作。&lt;/p></description></item><item><title>Skip List</title><link>https://ileonli.github.io/posts/skiplist/</link><pubDate>Wed, 18 Sep 2024 21:09:06 +0800</pubDate><guid>https://ileonli.github.io/posts/skiplist/</guid><description>&lt;h1 id="skip-list">Skip List&lt;/h1>
&lt;h2 id="linkedlist">LinkedList&lt;/h2>
&lt;p>在讨论跳表前，我们先回顾一下链表（&lt;code>LinkedList&lt;/code>），链表有以下优点和缺点：&lt;/p>
&lt;ul>
&lt;li>链表插入和删除给定的节点，只需要更改指针的指向位置即可，因此空间复杂度为 O(1)。&lt;/li>
&lt;li>对于搜索操作，由于链表是无序的（无法使用二分查找），只能从头部搜索到尾部，空间复杂度为 O(n)。&lt;/li>
&lt;/ul>
&lt;p>为了加快链表搜索过程，跳表引入了分层的概念。跳表的每一层都是一个有序链表，且最底层是初始的有序链表（包含所有元素）。每个位于第 &lt;code>i&lt;/code> 层的节点有 &lt;code>p&lt;/code> 的概率出现在第 &lt;code>i+1&lt;/code> 层，&lt;code>p&lt;/code> 为常数。&lt;/p>
&lt;p>跳表的多层索引机制在逻辑上模仿了二分查找的分治策略，使得链表也能实现&lt;strong>对数时间复杂度&lt;/strong>的查找。&lt;/p>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>跳表是一种可以替代平衡树的数据结构。跳表使用概率平衡，而不是严格的平衡维护，因此，跳表中插入和删除的算法比平衡树中的等价算法要简单得多，速度也显著更快。通过在链表上添加索引，达到优化查询的目的。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>概率算法（Probabilistic Algorithm）&lt;/strong>：算法的执行过程中使用随机数来影响决策或流程的算法。这意味着即使对于相同的输入，算法每次运行的结果或执行路径也可能不同。&lt;/p>&lt;/blockquote>
&lt;p>每个元素在跳表中由一个节点表示（如下图所示），节点是以 &lt;code>key&lt;/code> 的顺序有序排列的。且每个节点都有一个高度（height）或级别（level），表示该节点拥有的前向指针的数量。&lt;/p>
&lt;p>当插入节点时，会随机生成节点的高度，而不需要考虑当前跳表中的元素数量。&lt;/p>
&lt;p>&lt;img src="https://ileonli.github.io/images/skiplist/skiplist.png" alt="">&lt;/p>
&lt;p>对于上图中的链表，我们可以发现下边的规律：&lt;/p>
&lt;ul>
&lt;li>第 0 层：这是完整的链表，包含所有按顺序排列的元素。&lt;/li>
&lt;li>第 1 层：这一层包含第 0 层中大约一半的元素。通过从第 0 层中随机选择大约一半的节点，并将它们链接到第 1 层。&lt;/li>
&lt;li>第 2 层：这一层包含第 1 层中大约一半的元素，意味着它包含第 0 层总元素数的 1/4 左右。&lt;/li>
&lt;li>第 3 层：这一层包含第 2 层中大约一半的元素，大约是第 0 层总元素数的 1/8，以此类推。&lt;/li>
&lt;/ul>
&lt;h2 id="数据结构">数据结构&lt;/h2>
&lt;h3 id="node-类">Node 类&lt;/h3>
&lt;p>使用 &lt;code>Node&lt;/code> 类来表示跳表中的最底层的节点，该类有以下属性：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Node&lt;/code> 使用 &lt;code>K key&lt;/code> 和 &lt;code>V value&lt;/code> 分别表示键和值。&lt;/li>
&lt;li>&lt;code>Node&amp;lt;K, V&amp;gt;[] forwards&lt;/code> 表示该节点上的索引，该数组的初始长度为跳表的最大高度（DEFAULT_MAX_LEVEL），如果 &lt;code>forwards[i]&lt;/code> 指向 &lt;code>null&lt;/code>，表示第 &lt;code>i&lt;/code> 层不指向下一列（没有索引）。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>K &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;lt;&lt;/span>K&lt;span style="color:#f92672">&amp;gt;&lt;/span>, V&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> K key;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> V value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;[]&lt;/span> forwards;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@SuppressWarnings&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unchecked&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span>(K key, V value, &lt;span style="color:#66d9ef">int&lt;/span> level) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#f92672">=&lt;/span> key;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">=&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">forwards&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node&lt;span style="color:#f92672">[&lt;/span>level&lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#75715e">// level 为跳表的最高高度&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="skiplist">SkipList&lt;/h3>
&lt;p>使用 &lt;code>SkipList&lt;/code> 类来表示跳表，该类有以下属性：&lt;/p></description></item><item><title>Java 方法句柄（翻译）</title><link>https://ileonli.github.io/posts/java/method-handles/</link><pubDate>Thu, 08 Aug 2024 20:32:01 +0800</pubDate><guid>https://ileonli.github.io/posts/java/method-handles/</guid><description>&lt;h1 id="java-方法句柄翻译">Java 方法句柄（翻译）&lt;/h1>
&lt;blockquote>
&lt;p>翻译自：&lt;a href="https://dev.java/learn/introduction_to_method_handles/" target="_blank" rel="noopener noreferrer">https://dev.java/learn/introduction_to_method_handles/&lt;/a>&lt;/p>&lt;/blockquote>
&lt;h2 id="什么是方法句柄what-are-method-handles">什么是方法句柄（What are method handles）&lt;/h2>
&lt;p>方法句柄是一种用于查找和调用方法的低级机制。与反射一样，方法句柄也提供了调用方法、调用构造函数以及访问字段的手段。&lt;/p>
&lt;p>那么，方法句柄究竟什么是呢？它是对底层方法、构造函数或字段的可调用引用。方法句柄允许在一个简单的指向方法的引用之上进行一系列操作，这些操作包括插入或重新排列参数、转换返回值等。&lt;/p>
&lt;p>让我们深入探讨一下方法句柄能够提供什么功能以及我们如何有效地使用它们。&lt;/p>
&lt;h2 id="访问检查access-checking">访问检查（Access checking）&lt;/h2>
&lt;p>方法句柄的访问检查与反射的执行方式是不同的。&lt;strong>使用反射时&lt;/strong>，每次调用都会对调用者进行访问检查。&lt;strong>而对于方法句柄&lt;/strong>，访问检查只在方法句柄创建时进行。&lt;/p>
&lt;p>需要注意的是，如果在能够访问非公共成员的上下文中创建了方法句柄，那么当该方法句柄被传递到外部时，可以通过方法句柄访问非公共成员。&lt;/p>
&lt;p>因此，非公共成员可能会被不应有访问权限的代码访问。开发者有责任将此类方法句柄限制在其创建的上下文内。另外，可以直接使用合适的查找对象来创建具有访问限制的方法句柄。&lt;/p>
&lt;h2 id="方法句柄查找method-handle-lookup">方法句柄查找（Method handle lookup）&lt;/h2>
&lt;p>要创建方法句柄，我们首先需要创建一个 &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html" target="_blank" rel="noopener noreferrer">&lt;code>LookUp&lt;/code>&lt;/a> 对象，此为创建方法句柄的工厂。根据 &lt;code>Lookup&lt;/code> 对象本身或方法句柄的使用方式，我们可以决定是否需要限制其访问级别。&lt;/p>
&lt;p>例如，如果我们创建了一个指向私有方法的方法句柄，并且该方法句柄可以从外部访问，那么该私有方法也就可以被外部访问（译者注：现在，外部代码可以直接调用原本受保护的私有方法，从而破坏了方法的私有性）。&lt;/p>
&lt;p>通常我们希望避免这种情况。&lt;strong>一种办法&lt;/strong>是将 &lt;code>Lookup&lt;/code> 对象和方法句柄设为私有。&lt;strong>另一种方法&lt;/strong>是使用 &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.html#publicLookup%28%29" target="_blank" rel="noopener noreferrer">&lt;code>MethodHandles.publicLookup&lt;/code>&lt;/a> 方法创建 &lt;code>Lookup&lt;/code> 对象，这样它只能查找公共类的公共成员（译者注：未导出的包，或受保护或私有的类和成员不会被搜索到）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>MethodHandles.&lt;span style="color:#a6e22e">Lookup&lt;/span> publicLookup &lt;span style="color:#f92672">=&lt;/span> MethodHandles.&lt;span style="color:#a6e22e">publicLookup&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果我们打算将 &lt;code>Lookup&lt;/code> 对象和方法句柄设为私有，那么访问私有和受保护的成员是安全的（外部无法访问私有的方法句柄）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>MethodHandles.&lt;span style="color:#a6e22e">Lookup&lt;/span> lookup &lt;span style="color:#f92672">=&lt;/span> MethodHandles.&lt;span style="color:#a6e22e">lookup&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="方法类型method-type">方法类型（Method type）&lt;/h2>
&lt;p>要查找方法句柄，我们还需要提供方法或字段的类型信息。方法的类型信息通过 &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodType.html" target="_blank" rel="noopener noreferrer">&lt;code>MethodType&lt;/code>&lt;/a> 类表示。为了实例化一个 &lt;code>MethodType&lt;/code> 对象，需要提供函数返回类型作为第一个形参，后跟函数所有实参类型:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>MethodType methodType &lt;span style="color:#f92672">=&lt;/span> MethodType.&lt;span style="color:#a6e22e">methodType&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>.&lt;span style="color:#a6e22e">class&lt;/span> &lt;span style="color:#75715e">/* the method returns integer */&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String.&lt;span style="color:#a6e22e">class&lt;/span> &lt;span style="color:#75715e">/* and accepts a single String argument*/&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有了 &lt;code>Lookup&lt;/code> 和 &lt;code>MethodType&lt;/code> 实例后，我们就可以查找方法句柄了。&lt;/p></description></item><item><title>Java JDBC</title><link>https://ileonli.github.io/posts/java/jdbc/</link><pubDate>Sat, 03 Aug 2024 17:25:03 +0800</pubDate><guid>https://ileonli.github.io/posts/java/jdbc/</guid><description>&lt;h1 id="java-jdbc">Java JDBC&lt;/h1>
&lt;blockquote>
&lt;p>本教程使用 MySQL 数据库。&lt;/p>
&lt;p>主要参考：https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html&lt;/p>&lt;/blockquote>
&lt;h2 id="建立连接">建立连接&lt;/h2>
&lt;p>数据源可以是数据库管理系统 (DBMS)、传统文件系统或其他带有相应 JDBC 驱动的数据源。通常，JDBC 使用以下两种类之一来连接目标数据源：&lt;/p>
&lt;ul>
&lt;li>&lt;code>DriverManager&lt;/code>：用于将应用程序连接到通过数据库 URL 指定的数据源。当此类首次尝试建立连接时，它会自动加载类路径中找到的任何 JDBC 4.0 驱动程序。必须手动加载任何 4.0 版本之前的 JDBC 驱动程序。&lt;/li>
&lt;li>&lt;code>DataSource&lt;/code>：相比于 &lt;code>DriverManager&lt;/code>，更推荐使用此接口，因为它允许应用程序对底层数据源的细节保持透明。&lt;code>DataSource&lt;/code> 对象的属性被设置为表示特定的数据源。&lt;/li>
&lt;/ul>
&lt;h3 id="使用-drivermanager-类">使用 &lt;code>DriverManager&lt;/code> 类&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>String url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;jdbc:mysql://localhost:3306/db&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String username &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>, password &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0987654321&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection conn &lt;span style="color:#f92672">=&lt;/span> DriverManager.&lt;span style="color:#a6e22e">getConnection&lt;/span>(url, username, password);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用-jdbc-处理-sql-语句">使用 JDBC 处理 SQL 语句&lt;/h2>
&lt;p>新建一个 &lt;code>user&lt;/code> 表，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://ileonli.github.io/images/JDBC/User.png" alt="">&lt;/p>
&lt;p>使用 &lt;code>conn&lt;/code> 对象创建 &lt;code>Statement&lt;/code>，使用 &lt;code>stmt&lt;/code> 执行 SQL 语句。&lt;/p>
&lt;p>&lt;code>ResultSet&lt;/code> 保存了执行 SQL 语句的结果，可以遍历保存的结果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>String query &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SELECT * FROM `user`;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> (Statement stmt &lt;span style="color:#f92672">=&lt;/span> conn.&lt;span style="color:#a6e22e">createStatement&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ResultSet rs &lt;span style="color:#f92672">=&lt;/span> stmt.&lt;span style="color:#a6e22e">executeQuery&lt;/span>(query);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (rs.&lt;span style="color:#a6e22e">next&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> rs.&lt;span style="color:#a6e22e">getInt&lt;/span>(1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String name &lt;span style="color:#f92672">=&lt;/span> rs.&lt;span style="color:#a6e22e">getString&lt;/span>(2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> age &lt;span style="color:#f92672">=&lt;/span> rs.&lt;span style="color:#a6e22e">getInt&lt;/span>(3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String email &lt;span style="color:#f92672">=&lt;/span> rs.&lt;span style="color:#a6e22e">getString&lt;/span>(4);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;id: %d, name: %s, age: %d, email: %s.\n&amp;#34;&lt;/span>, id, name, age, email);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用-preparedstatements">使用 PreparedStatements&lt;/h2>
&lt;p>如果需要多次执行一个 &lt;code>Statement&lt;/code> 对象，使用 &lt;code>PreparedStatement&lt;/code> 对象可以减少执行时间。&lt;/p></description></item><item><title>阻塞与非阻塞 I/O 和 epoll（翻译）</title><link>https://ileonli.github.io/posts/network-programming/block-and-nonblock-io/</link><pubDate>Fri, 12 Jul 2024 22:59:06 +0800</pubDate><guid>https://ileonli.github.io/posts/network-programming/block-and-nonblock-io/</guid><description>&lt;h1 id="阻塞与非阻塞-io-和-epoll翻译">阻塞与非阻塞 I/O 和 epoll（翻译）&lt;/h1>
&lt;blockquote>
&lt;p>原文：https://eklitzke.org/blocking-io-nonblocking-io-and-epoll&lt;/p>&lt;/blockquote>
&lt;p>在这篇文章中，我想解释使用非阻塞 I/O 时会发生什么。我特别想说明的是:&lt;/p>
&lt;ol>
&lt;li>使用 &lt;code>fcntl&lt;/code> 函数设置文件描述符的 &lt;code>O_NONBLOCK&lt;/code> 时的语义。&lt;/li>
&lt;li>非阻塞（nonblocking） I/O 与异步（asynchronous） I/O 的区别。&lt;/li>
&lt;li>为什么非阻塞 I/O 经常与诸如 &lt;code>select&lt;/code>、&lt;code>epoll&lt;/code> 和 &lt;code>kqueue&lt;/code> 等 I/O 多路复用器一起使用。&lt;/li>
&lt;li>非阻塞模式如何与 &lt;code>epoll&lt;/code> 中的边缘触发轮询交互。&lt;/li>
&lt;/ol>
&lt;h2 id="阻塞模式">阻塞模式&lt;/h2>
&lt;p>默认情况下，Unix 系统所有的文件描述符都以“阻塞模式”启动。这意味着像 &lt;code>read&lt;/code>、&lt;code>write&lt;/code> 或 &lt;code>connect&lt;/code> 这样的 I/O 系统调用可能会阻塞。一个很容易理解的方法是当你从一个普通的基于 TTY 的程序中的 &lt;code>stdin&lt;/code> 读取数据时会发生什么。如果你在 &lt;code>stdin&lt;/code>上调用 &lt;code>read&lt;/code>，那么你的程序将会阻塞，直到数据实际上可用，比如当用户实际上在键盘上键入字符时。具体来说，内核会将进程置于“睡眠”状态，直到 &lt;code>stdin&lt;/code> 上的数据可用。其他类型的文件描述符也是如此。例如，如果你尝试从 TCP 套接字中读取数据，那么 &lt;code>read&lt;/code> 调用将会阻塞，直到连接的另一端实际上发送数据。&lt;/p>
&lt;p>阻塞对于应该并发运行的程序来说是一个问题，因为被阻塞的进程会被挂起。解决这个问题有两种不同但互补的方式：&lt;/p>
&lt;ol>
&lt;li>非阻塞模式。&lt;/li>
&lt;li>I/O 多路复用系统调用，例如 &lt;code>select&lt;/code> 和 &lt;code>epoll&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>这两种解决方案经常一起使用，但它们是解决这个问题的独立策略，通常两者都会被使用。接下来我们将会看到它们之间的区别以及为什么它们通常都会被同时使用。&lt;/p>
&lt;h2 id="非阻塞模式">非阻塞模式&lt;/h2>
&lt;p>通过 &lt;code>fcntl&lt;/code> 函数在文件描述符的标志集中添加 &lt;code>O_NONBLOCK&lt;/code>，可以将文件描述符设置为“非阻塞模式”：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* set O_NONBLOCK on fd */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> flags &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fcntl&lt;/span>(fd, F_GETFL, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fcntl&lt;/span>(fd, F_SETFL, flags &lt;span style="color:#f92672">|&lt;/span> O_NONBLOCK);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从这一点开始，文件描述符被视为非阻塞的。当发生这种情况时，像 &lt;code>read&lt;/code> 和 &lt;code>write&lt;/code> 这样的 I/O 系统调用将返回 -1，并且 &lt;code>errno&lt;/code> 将被设置为 &lt;code>EWOULDBLOCK&lt;/code>。&lt;/p></description></item><item><title>Linux 网络编程</title><link>https://ileonli.github.io/posts/network-programming/network-programming/</link><pubDate>Wed, 10 Jul 2024 15:20:00 +0800</pubDate><guid>https://ileonli.github.io/posts/network-programming/network-programming/</guid><description>&lt;h1 id="linux-网络编程">Linux 网络编程&lt;/h1>
&lt;h2 id="网络字节序">网络字节序&lt;/h2>
&lt;h3 id="大小端">大小端&lt;/h3>
&lt;p>不同架构的 CPU 中，4 字节整数 1 在内存中存储的方式是不同的。&lt;/p>
&lt;ul>
&lt;li>大端序（big endian）：&lt;strong>最高位&lt;/strong>有效字节存储在&lt;strong>低内存地址&lt;/strong>，而&lt;strong>最低位&lt;/strong>有效字节存储在&lt;strong>高内存地址&lt;/strong>。&lt;/li>
&lt;li>小端序（little endian）：&lt;strong>最高位&lt;/strong>有效字节存储在&lt;strong>高内存地址&lt;/strong>，而&lt;strong>最低位&lt;/strong>有效字节存储在&lt;strong>低内存地址&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>对于一个 4 字节整数 &lt;code>0x01020304&lt;/code>，大小端序存储方式分别如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>地址: 0 1 2 3 （大端序保存）
 01 02 03 04
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>地址: 0 1 2 3 （小端序保存）
 04 03 02 01
&lt;/code>&lt;/pre>&lt;hr>
&lt;p>可以使用下边的方法判断机器的字节序：&lt;/p>
&lt;ol>
&lt;li>通过 &lt;code>endian.h&lt;/code> 提供的 &lt;code>BYTE_ORDER&lt;/code> 宏。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;endian.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">big_endian&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> BYTE_ORDER &lt;span style="color:#f92672">==&lt;/span> BIG_ENDIAN;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">little_endian&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> BYTE_ORDER &lt;span style="color:#f92672">==&lt;/span> LITTLE_ENDIAN;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>将 &lt;code>uint16_t&lt;/code> 类型的数字转为 &lt;code>char *&lt;/code>，通过高字节和低字节进行判断。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">big_endian&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint16_t&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0102&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ((&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>) (&lt;span style="color:#f92672">&amp;amp;&lt;/span>val))[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0x01&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">little_endian&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint16_t&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0102&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ((&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>) (&lt;span style="color:#f92672">&amp;amp;&lt;/span>val))[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0x01&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>和方法 2 类似，利用的是 &lt;code>union&lt;/code> 相同的内存位置存储不同的数据类型。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">union&lt;/span> endian {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint16_t&lt;/span> val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> bytes[&lt;span style="color:#ae81ff">2&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">big_endian&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">union&lt;/span> endian en{};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> en.val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0102&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> en.bytes[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0x01&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">little_endian&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">union&lt;/span> endian en{};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> en.val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0102&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> en.bytes[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0x02&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>为什么有两种不同的字节序？&lt;/p></description></item><item><title>Java HashMap 源码</title><link>https://ileonli.github.io/posts/java/hashmap/</link><pubDate>Tue, 15 Feb 2022 20:37:01 +0800</pubDate><guid>https://ileonli.github.io/posts/java/hashmap/</guid><description>&lt;h1 id="java-hashmap-源码">Java HashMap 源码&lt;/h1>
&lt;h2 id="属性">属性&lt;/h2>
&lt;h3 id="默认长度">默认长度&lt;/h3>
&lt;p>如不传入初始化长度，则默认长度为 16&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * The default initial capacity - MUST be a power of two.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> DEFAULT_INITIAL_CAPACITY &lt;span style="color:#f92672">=&lt;/span> 1 &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> 4; &lt;span style="color:#75715e">// aka 16&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="阈值">阈值&lt;/h3>
&lt;p>所能容纳的 key-value 对的极限，超过此值就需要进行扩容&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * The next size value at which to resize (capacity * load factor).
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> threshold;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="底层数组">底层数组&lt;/h3>
&lt;p>HashMap 底层存放 Node 节点的数组，在第一次使用的时候进行初始化，长度总为 2 的 N 次幂&lt;/p>
&lt;p>HashMap 保证扩容后长度 n 总为 2 次方是因为计算 Node 所在索引时采用了 &lt;code>(n - 1) &amp;amp; hash&lt;/code> 运算进行优化（&amp;amp; 比 % 效率更高），等价于对 n 取模，也就是 h % n&lt;/p></description></item><item><title>Java ArrayList 源码</title><link>https://ileonli.github.io/posts/java/arraylist/</link><pubDate>Thu, 03 Feb 2022 15:24:06 +0800</pubDate><guid>https://ileonli.github.io/posts/java/arraylist/</guid><description>&lt;h1 id="java-arraylist-源码">Java ArrayList 源码&lt;/h1>
&lt;h2 id="属性">属性&lt;/h2>
&lt;p>从类中的属性中可以看到，&lt;code>ArrayList&lt;/code> 默认容量为 10，底层使用一个 &lt;code>Object[]&lt;/code> 数组保存所有元素。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Default initial capacity.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> DEFAULT_CAPACITY &lt;span style="color:#f92672">=&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Shared empty array instance used for empty instances.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span> EMPTY_ELEMENTDATA &lt;span style="color:#f92672">=&lt;/span> {};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Shared empty array instance used for default sized empty instances. We
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * first element is added.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA &lt;span style="color:#f92672">=&lt;/span> {};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * The array buffer into which the elements of the ArrayList are stored.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * The capacity of the ArrayList is the length of this array buffer. Any
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * will be expanded to DEFAULT_CAPACITY when the first element is added.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">transient&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span> elementData; &lt;span style="color:#75715e">// non-private to simplify nested class access&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * The size of the ArrayList (the number of elements it contains).
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @serial
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> size;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="构造器">构造器&lt;/h2>
&lt;h3 id="默认构造器">默认构造器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Constructs an empty list with an initial capacity of ten.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">ArrayList&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">elementData&lt;/span> &lt;span style="color:#f92672">=&lt;/span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="指定长度">指定长度&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Constructs an empty list with the specified initial capacity.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param initialCapacity the initial capacity of the list
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @throws IllegalArgumentException if the specified initial capacity
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * is negative
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">ArrayList&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> initialCapacity) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (initialCapacity &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 新建长度为 initialCapacity 的数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">elementData&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Object&lt;span style="color:#f92672">[&lt;/span>initialCapacity&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (initialCapacity &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">elementData&lt;/span> &lt;span style="color:#f92672">=&lt;/span> EMPTY_ELEMENTDATA;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;Illegal Capacity: &amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialCapacity);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="传入集合">传入集合&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Constructs a list containing the elements of the specified
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * collection, in the order they are returned by the collection&amp;#39;s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * iterator.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param c the collection whose elements are to be placed into this list
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @throws NullPointerException if the specified collection is null
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">ArrayList&lt;/span>(Collection&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> E&lt;span style="color:#f92672">&amp;gt;&lt;/span> c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elementData &lt;span style="color:#f92672">=&lt;/span> c.&lt;span style="color:#a6e22e">toArray&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// 如果传入的集合长度不为 0 ，则把集合中的元素 copy 到 elementData 中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((size &lt;span style="color:#f92672">=&lt;/span> elementData.&lt;span style="color:#a6e22e">length&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// defend against c.toArray (incorrectly) not returning Object[]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (elementData.&lt;span style="color:#a6e22e">getClass&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span>.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elementData &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">copyOf&lt;/span>(elementData, size, Object&lt;span style="color:#f92672">[]&lt;/span>.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// replace with empty array.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">elementData&lt;/span> &lt;span style="color:#f92672">=&lt;/span> EMPTY_ELEMENTDATA;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="扩容">扩容&lt;/h2>
&lt;h3 id="最大长度">最大长度&lt;/h3>
&lt;p>根据注释可以看到，有些虚拟机需要在数组中保存额外信息（&lt;a href="https://stackoverflow.com/questions/35756277/why-the-maximum-array-size-of-arraylist-is-integer-max-value-8" target="_blank" rel="noopener noreferrer">保存的额外信息&lt;/a>）需要占用一定的空间，所以 &lt;code>ArrayList&lt;/code> 的最大长度为 &lt;code>2^32 - 8&lt;/code>&lt;/p></description></item><item><title>Java 中的引用类型</title><link>https://ileonli.github.io/posts/java/reference/</link><pubDate>Sat, 21 Aug 2021 14:21:05 +0800</pubDate><guid>https://ileonli.github.io/posts/java/reference/</guid><description>&lt;h1 id="java-中的引用类型">Java 中的引用类型&lt;/h1>
&lt;blockquote>
&lt;p>为什么 JDK 中会设计这么多中引用类型呢？&lt;/p>&lt;/blockquote>
&lt;p>首先，Java 是一门自带 GC 的语言，意味着我们不用像 C++ 一样手动管理内存，Java 会自动清除不需要的对象，但这样我们就无法控制对象的生命周期。&lt;/p>
&lt;p>系统中存在大量的对象，其重要程度和生命周期是不同的。因此我们可以利用不同的引用类型控制 GC 回收对象的时间。当内存空间还足够时，对象可以保留在内存中；内存空间在进行垃圾回收后仍然紧张，就可以抛弃某些对象释放内存。&lt;/p>
&lt;p>JDK 1.2 之后，Java 对引用对象进行了分类，从上到下引用类型逐渐变弱：&lt;/p>
&lt;ul>
&lt;li>Strong Reference（强引用）&lt;/li>
&lt;li>Soft Reference（软引用）&lt;/li>
&lt;li>Week Reference（弱引用）&lt;/li>
&lt;li>Phantom Reference（虚引用）&lt;/li>
&lt;/ul>
&lt;h2 id="referencequeue">ReferenceQueue&lt;/h2>
&lt;p>当引用的对象被清除的时候，会把用于包装对象的 &lt;code>Reference(Week, Soft, Phantom)&lt;/code> 传入到 &lt;code>ReferenceQueue&lt;/code> 中，后续可从队列中获取，进行后续处理 &lt;code>Reference&lt;/code> ，比如判断是否发生内存泄漏等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.lang.ref.Reference;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.lang.ref.ReferenceQueue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.lang.ref.WeakReference;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.HashMap;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Main&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReferenceQueue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">[]&amp;gt;&lt;/span> queue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ReferenceQueue&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 产生大对象，使 GC 清理对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>WeakReference&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">[]&amp;gt;&lt;/span>, Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10000; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> WeakReference&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> Integer&lt;span style="color:#f92672">[&lt;/span>1024 &lt;span style="color:#f92672">*&lt;/span> 1024&lt;span style="color:#f92672">]&lt;/span>, queue), i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }).&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 监控清理的对象，此时对象已经被清理，只剩下 WeakReference 引用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Reference&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Integer&lt;span style="color:#f92672">[]&amp;gt;&lt;/span> ref;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((ref &lt;span style="color:#f92672">=&lt;/span> queue.&lt;span style="color:#a6e22e">remove&lt;/span>()) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;对象引用：%s, 对象：%s\n&amp;#34;&lt;/span>, ref, ref.&lt;span style="color:#a6e22e">get&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.&lt;span style="color:#a6e22e">printStackTrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }).&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="strongreference">StrongReference&lt;/h2>
&lt;p>当我们利用 &lt;code>new&lt;/code> 新建对象时 &lt;code>=&lt;/code> 就是强引用，只要引用关系存在，GC 就不会清除被引用的对象。&lt;/p></description></item></channel></rss>