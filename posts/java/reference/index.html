<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=content-type content="text/html"><meta name=viewport content="width=device-width,initial-scale=1"><title itemprop=name>Java 中的引用类型 | Leon's Blog</title>
<meta property="og:title" content="Java 中的引用类型 | Leon's Blog"><meta name=twitter:title content="Java 中的引用类型 | Leon's Blog"><meta itemprop=name content="Java 中的引用类型 | Leon's Blog"><meta name=application-name content="Java 中的引用类型 | Leon's Blog"><meta property="og:site_name" content="Leon's Blog"><meta name=description content="支持亮色和暗色模式的极简 Hugo 博客主题"><meta itemprop=description content="支持亮色和暗色模式的极简 Hugo 博客主题"><meta property="og:description" content="支持亮色和暗色模式的极简 Hugo 博客主题"><meta name=twitter:description content="支持亮色和暗色模式的极简 Hugo 博客主题"><meta property="og:locale" content="zh-cn"><meta name=language content="zh-cn"><link rel=alternate hreflang=zh-cn href=https://ileonli.github.io/posts/java/reference/ title=Chinese><meta property="og:type" content="article"><meta property="og:article:published_time" content=2021-08-21T14:21:05+0800><meta property="article:published_time" content=2021-08-21T14:21:05+0800><meta property="og:url" content="https://ileonli.github.io/posts/java/reference/"><meta property="og:article:author" content="Leon Li"><meta property="article:author" content="Leon Li"><meta name=author content="Leon Li"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"Java 中的引用类型","author":{"@type":"Person","name":""},"datePublished":"2021-08-21","description":"","wordCount":361,"mainEntityOfPage":"True","dateModified":"2021-08-21","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"Leon\u0027s Blog"}}</script><meta name=generator content="Hugo 0.146.4"><meta property="og:url" content="https://ileonli.github.io/posts/java/reference/"><meta property="og:site_name" content="Leon's Blog"><meta property="og:title" content="Java 中的引用类型"><meta property="og:description" content='Java 中的引用类型 为什么 JDK 中会设计这么多中引用类型呢？
首先，Java 是一门自带 GC 的语言，意味着我们不用像 C++ 一样手动管理内存，Java 会自动清除不需要的对象，但这样我们就无法控制对象的生命周期。
系统中存在大量的对象，其重要程度和生命周期是不同的。因此我们可以利用不同的引用类型控制 GC 回收对象的时间。当内存空间还足够时，对象可以保留在内存中；内存空间在进行垃圾回收后仍然紧张，就可以抛弃某些对象释放内存。
JDK 1.2 之后，Java 对引用对象进行了分类，从上到下引用类型逐渐变弱：
Strong Reference（强引用） Soft Reference（软引用） Week Reference（弱引用） Phantom Reference（虚引用） ReferenceQueue 当引用的对象被清除的时候，会把用于包装对象的 Reference(Week, Soft, Phantom) 传入到 ReferenceQueue 中，后续可从队列中获取，进行后续处理 Reference ，比如判断是否发生内存泄漏等。
import java.lang.ref.Reference; import java.lang.ref.ReferenceQueue; import java.lang.ref.WeakReference; import java.util.HashMap; public class Main { public static void main(String[] args) { ReferenceQueue<Integer[]> queue = new ReferenceQueue<>(); // 产生大对象，使 GC 清理对象 new Thread(() -> { HashMap<WeakReference<Integer[]>, Integer> map = new HashMap<>(); for (int i = 0; i < 10000; i++) { map.put(new WeakReference<>(new Integer[1024 * 1024], queue), i); } }).start(); // 监控清理的对象，此时对象已经被清理，只剩下 WeakReference 引用 new Thread(() -> { Reference<? extends Integer[]> ref; while (true) { try { while ((ref = queue.remove()) != null) { System.out.printf("对象引用：%s, 对象：%s\n", ref, ref.get()); } } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); } } StrongReference 当我们利用 new 新建对象时 = 就是强引用，只要引用关系存在，GC 就不会清除被引用的对象。'><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-21T14:21:05+08:00"><meta property="article:modified_time" content="2021-08-21T14:21:05+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java 中的引用类型"><meta name=twitter:description content='Java 中的引用类型 为什么 JDK 中会设计这么多中引用类型呢？
首先，Java 是一门自带 GC 的语言，意味着我们不用像 C++ 一样手动管理内存，Java 会自动清除不需要的对象，但这样我们就无法控制对象的生命周期。
系统中存在大量的对象，其重要程度和生命周期是不同的。因此我们可以利用不同的引用类型控制 GC 回收对象的时间。当内存空间还足够时，对象可以保留在内存中；内存空间在进行垃圾回收后仍然紧张，就可以抛弃某些对象释放内存。
JDK 1.2 之后，Java 对引用对象进行了分类，从上到下引用类型逐渐变弱：
Strong Reference（强引用） Soft Reference（软引用） Week Reference（弱引用） Phantom Reference（虚引用） ReferenceQueue 当引用的对象被清除的时候，会把用于包装对象的 Reference(Week, Soft, Phantom) 传入到 ReferenceQueue 中，后续可从队列中获取，进行后续处理 Reference ，比如判断是否发生内存泄漏等。
import java.lang.ref.Reference; import java.lang.ref.ReferenceQueue; import java.lang.ref.WeakReference; import java.util.HashMap; public class Main { public static void main(String[] args) { ReferenceQueue<Integer[]> queue = new ReferenceQueue<>(); // 产生大对象，使 GC 清理对象 new Thread(() -> { HashMap<WeakReference<Integer[]>, Integer> map = new HashMap<>(); for (int i = 0; i < 10000; i++) { map.put(new WeakReference<>(new Integer[1024 * 1024], queue), i); } }).start(); // 监控清理的对象，此时对象已经被清理，只剩下 WeakReference 引用 new Thread(() -> { Reference<? extends Integer[]> ref; while (true) { try { while ((ref = queue.remove()) != null) { System.out.printf("对象引用：%s, 对象：%s\n", ref, ref.get()); } } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); } } StrongReference 当我们利用 new 新建对象时 = 就是强引用，只要引用关系存在，GC 就不会清除被引用的对象。'><link rel=canonical href=https://ileonli.github.io/posts/java/reference/><link href=/style.min.2d921c18cf1ec555ffc03d59a8adc211c402c68c930c27d6a0c306ab175a8d09.css rel=stylesheet><link href=/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css rel=stylesheet><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/icons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/icons/favicon-16x16.png><link rel=mask-icon href=/icons/safari-pinned-tab.svg><link rel="shortcut icon" href=/favicon.ico><link rel=manifest href=https://ileonli.github.io/site.webmanifest><meta name=msapplication-config content="/browserconfig.xml"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#434648"><link rel=icon type=image/svg+xml href=/icons/favicon.svg></head><body data-theme=auto class=notransition><script src=/js/theme.min.8961c317c5b88b953fe27525839672c9343f1058ab044696ca225656c8ba2ab0.js integrity="sha256-iWHDF8W4i5U/4nUlg5ZyyTQ/EFirBEaWyiJWVsi6KrA="></script><div class=navbar role=navigation><nav class=menu aria-label="Main Navigation"><a href=https://ileonli.github.io/ class=logo><svg width="25" height="25" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"><title>首页</title><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
</a><input type=checkbox id=menu-trigger class=menu-trigger>
<label for=menu-trigger><span class=menu-icon><svg width="25" height="25" stroke="currentcolor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7H3.40726"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M.5 12.5V1.5c0-.552285.447715-1 1-1h11C13.0523.5 13.5.947715 13.5 1.5v11C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C.947715 13.5.5 13.0523.5 12.5z"/></svg></span></label><div class=trigger><ul class=trigger-container><li><a class=menu-link href=/>首页</a></li><li><a class="menu-link active" href=/posts/>文章</a></li><li><a class=menu-link href=/about/>关于</a></li><li class=menu-separator><span>|</span></li></ul><a id=mode href=#><svg class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg><svg class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg></a></div></nav></div><div class="wrapper post"><main class=page-content aria-label=Content><article><header class=header><h1 class=header-title>Java 中的引用类型</h1><div class=post-meta><time datetime=2021-08-21T14:21:05+08:00 itemprop=datePublished>2021年08月21日</time></div></header><details class=toc zgotmplz><summary><b>目录</b></summary><nav id=TableOfContents><ul><li><a href=#referencequeue>ReferenceQueue</a></li><li><a href=#strongreference>StrongReference</a></li><li><a href=#softreference>SoftReference</a></li><li><a href=#weakreference>WeakReference</a></li><li><a href=#phantomreference>PhantomReference</a></li><li><a href=#四种引用比较>四种引用比较</a></li></ul></nav></details><div class=page-content><h1 id=java-中的引用类型>Java 中的引用类型</h1><blockquote><p>为什么 JDK 中会设计这么多中引用类型呢？</p></blockquote><p>首先，Java 是一门自带 GC 的语言，意味着我们不用像 C++ 一样手动管理内存，Java 会自动清除不需要的对象，但这样我们就无法控制对象的生命周期。</p><p>系统中存在大量的对象，其重要程度和生命周期是不同的。因此我们可以利用不同的引用类型控制 GC 回收对象的时间。当内存空间还足够时，对象可以保留在内存中；内存空间在进行垃圾回收后仍然紧张，就可以抛弃某些对象释放内存。</p><p>JDK 1.2 之后，Java 对引用对象进行了分类，从上到下引用类型逐渐变弱：</p><ul><li>Strong Reference（强引用）</li><li>Soft Reference（软引用）</li><li>Week Reference（弱引用）</li><li>Phantom Reference（虚引用）</li></ul><h2 id=referencequeue>ReferenceQueue</h2><p>当引用的对象被清除的时候，会把用于包装对象的 <code>Reference(Week, Soft, Phantom)</code> 传入到 <code>ReferenceQueue</code> 中，后续可从队列中获取，进行后续处理 <code>Reference</code> ，比如判断是否发生内存泄漏等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.lang.ref.Reference</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.lang.ref.ReferenceQueue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.lang.ref.WeakReference</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.util.HashMap</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Main</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ReferenceQueue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>[]&gt;</span><span class=w> </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReferenceQueue</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 产生大对象，使 GC 清理对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>WeakReference</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>[]&gt;</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>10000</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>WeakReference</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Integer</span><span class=o>[</span><span class=n>1024</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>1024</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>queue</span><span class=p>),</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 监控清理的对象，此时对象已经被清理，只剩下 WeakReference 引用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Reference</span><span class=o>&lt;?</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>Integer</span><span class=o>[]&gt;</span><span class=w> </span><span class=n>ref</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>while</span><span class=w> </span><span class=p>((</span><span class=n>ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>queue</span><span class=p>.</span><span class=na>remove</span><span class=p>())</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>printf</span><span class=p>(</span><span class=s>&#34;对象引用：%s, 对象：%s\n&#34;</span><span class=p>,</span><span class=w> </span><span class=n>ref</span><span class=p>,</span><span class=w> </span><span class=n>ref</span><span class=p>.</span><span class=na>get</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>InterruptedException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=strongreference>StrongReference</h2><p>当我们利用 <code>new</code> 新建对象时 <code>=</code> 就是强引用，只要引用关系存在，GC 就不会清除被引用的对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Main</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Object</span><span class=w> </span><span class=n>o</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Object</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=softreference>SoftReference</h2><p>软引用用于描述还有些用，但非必须的对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.lang.ref.ReferenceQueue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.lang.ref.SoftReference</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Main</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ReferenceQueue</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>refQ</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReferenceQueue</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Object</span><span class=w> </span><span class=n>o</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Object</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 创建对象 o 的软引用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>SoftReference</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>refOne</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>SoftReference</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>o</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 创建对象 o 的软引用，并传入 ReferenceQueue，当被清除时会传入队列中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>SoftReference</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>refTwo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>SoftReference</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>o</span><span class=p>,</span><span class=w> </span><span class=n>refQ</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在虚拟机抛出 <code>OutOfMemoryError</code> 之前，所有对软可达对象的软引用都保证已被清除。</p><p>只要软引用的引用是强可达（对象此时有强引用链）的，也就是说，它实际上是在使用的，软引用就不会被清除。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.lang.ref.SoftReference</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Main</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Object</span><span class=w> </span><span class=n>o</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Object</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>SoftReference</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>refOne</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>SoftReference</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>o</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 此时对象 o 有强引用，因此是强可达的</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Object</span><span class=w> </span><span class=n>otherO</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>o</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=weakreference>WeakReference</h2><p>弱引用描述那些非必需的对象，但强度比 <code>SoftReference</code> 更弱的对象，在下一次 GC 时无论当前内存是足够，都会清除只包含弱引用链的对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.lang.ref.ReferenceQueue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.lang.ref.WeakReference</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Main</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ReferenceQueue</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>refQ</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReferenceQueue</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Object</span><span class=w> </span><span class=n>o</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Object</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>WeakReference</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>refOne</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>WeakReference</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>o</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>WeakReference</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>refTwo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>WeakReference</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>o</span><span class=p>,</span><span class=w> </span><span class=n>refQ</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=phantomreference>PhantomReference</h2><p>也可以叫做 <strong>虚幻引用</strong> 或者 <strong>幻影引用</strong>，最弱的一种引用关系。</p><p>是否存在虚引用不会影响其生命周期，也无法取得对象实例。</p><p>唯一作用是在对象被清除的时候接收到系统的通知。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.lang.ref.PhantomReference</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.lang.ref.Reference</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.lang.ref.ReferenceQueue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Main</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ReferenceQueue</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>refQ</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReferenceQueue</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Object</span><span class=w> </span><span class=n>o</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Object</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>PhantomReference</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>PhantomReference</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>o</span><span class=p>,</span><span class=w> </span><span class=n>refQ</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 建议 GC</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>o</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>gc</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 等待获取被 GC 清除的对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Reference</span><span class=o>&lt;?&gt;</span><span class=w> </span><span class=n>reference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>refQ</span><span class=p>.</span><span class=na>remove</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>ref</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>reference</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// answer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>java</span><span class=p>.</span><span class=na>lang</span><span class=p>.</span><span class=na>ref</span><span class=p>.</span><span class=na>PhantomReference</span><span class=nd>@59a6e353</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>java</span><span class=p>.</span><span class=na>lang</span><span class=p>.</span><span class=na>ref</span><span class=p>.</span><span class=na>PhantomReference</span><span class=nd>@59a6e353</span><span class=w>
</span></span></span></code></pre></div><h2 id=四种引用比较>四种引用比较</h2><table><thead><tr><th>引用类型</th><th>清除时间</th></tr></thead><tbody><tr><td>StrongReference</td><td>强引用关系结束时</td></tr><tr><td>SoftReference</td><td>内存不足够时</td></tr><tr><td>WeakReference</td><td>在下一次 GC 发生时</td></tr><tr><td>PhantomReference</td><td>无</td></tr></tbody></table></div></article></main></div><footer class=footer><span class=footer_item></span>&nbsp;<div class=footer_social-icons><a href=https://github.com/ileonli target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=/index.xml target=_blank rel="noopener noreferrer me" title=Rss><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div><small class=footer_copyright>© 2025 Leon Li.
Powered by <a href=https://github.com/hugo-sid/hugo-blog-awesome target=_blank rel=noopener>Hugo blog awesome</a>.</small></footer><a href=# title=回到顶部 id=totop><svg width="48" height="48" fill="currentcolor" stroke="currentcolor" viewBox="0 96 960 960"><path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197z"/></svg>
</a><script src=https://ileonli.github.io/js/main.min.35f435a5d8eac613c52daa28d8af544a4512337d3e95236e4a4978417b8dcb2f.js integrity="sha256-NfQ1pdjqxhPFLaoo2K9USkUSM30+lSNuSkl4QXuNyy8="></script></body></html>