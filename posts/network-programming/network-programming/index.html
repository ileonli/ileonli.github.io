<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=content-type content="text/html"><meta name=viewport content="width=device-width,initial-scale=1"><title itemprop=name>Linux 网络编程 | Leon's Blog</title>
<meta property="og:title" content="Linux 网络编程 | Leon's Blog"><meta name=twitter:title content="Linux 网络编程 | Leon's Blog"><meta itemprop=name content="Linux 网络编程 | Leon's Blog"><meta name=application-name content="Linux 网络编程 | Leon's Blog"><meta property="og:site_name" content="Leon's Blog"><meta name=description content="支持亮色和暗色模式的极简 Hugo 博客主题"><meta itemprop=description content="支持亮色和暗色模式的极简 Hugo 博客主题"><meta property="og:description" content="支持亮色和暗色模式的极简 Hugo 博客主题"><meta name=twitter:description content="支持亮色和暗色模式的极简 Hugo 博客主题"><meta property="og:locale" content="zh-cn"><meta name=language content="zh-cn"><link rel=alternate hreflang=zh-cn href=https://ileonli.github.io/posts/network-programming/network-programming/ title=Chinese><meta property="og:type" content="article"><meta property="og:article:published_time" content=2024-07-10T15:20:00+0800><meta property="article:published_time" content=2024-07-10T15:20:00+0800><meta property="og:url" content="https://ileonli.github.io/posts/network-programming/network-programming/"><meta property="og:article:author" content="Leon Li"><meta property="article:author" content="Leon Li"><meta name=author content="Leon Li"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"Linux 网络编程","author":{"@type":"Person","name":""},"datePublished":"2024-07-10","description":"","wordCount":2724,"mainEntityOfPage":"True","dateModified":"2024-07-10","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"Leon\u0027s Blog"}}</script><meta name=generator content="Hugo 0.146.4"><meta property="og:url" content="https://ileonli.github.io/posts/network-programming/network-programming/"><meta property="og:site_name" content="Leon's Blog"><meta property="og:title" content="Linux 网络编程"><meta property="og:description" content="Linux 网络编程 网络字节序 大小端 不同架构的 CPU 中，4 字节整数 1 在内存中存储的方式是不同的。
大端序（big endian）：最高位有效字节存储在低内存地址，而最低位有效字节存储在高内存地址。 小端序（little endian）：最高位有效字节存储在高内存地址，而最低位有效字节存储在低内存地址。 对于一个 4 字节整数 0x01020304，大小端序存储方式分别如下：
地址: 0 1 2 3 （大端序保存） 01 02 03 04 地址: 0 1 2 3 （小端序保存） 04 03 02 01 可以使用下边的方法判断机器的字节序：
通过 endian.h 提供的 BYTE_ORDER 宏。 #include <endian.h> bool big_endian() { return BYTE_ORDER == BIG_ENDIAN; } bool little_endian() { return BYTE_ORDER == LITTLE_ENDIAN; } 将 uint16_t 类型的数字转为 char *，通过高字节和低字节进行判断。 bool big_endian() { uint16_t val = 0x0102; return ((char *) (&amp;val))[0] == 0x01; } bool little_endian() { uint16_t val = 0x0102; return ((char *) (&amp;val))[1] == 0x01; } 和方法 2 类似，利用的是 union 相同的内存位置存储不同的数据类型。 union endian { uint16_t val; char bytes[2]; }; bool big_endian() { union endian en{}; en.val = 0x0102; return en.bytes[0] == 0x01; } bool little_endian() { union endian en{}; en.val = 0x0102; return en.bytes[0] == 0x02; } 为什么有两种不同的字节序？"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-10T15:20:00+08:00"><meta property="article:modified_time" content="2024-07-10T15:20:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux 网络编程"><meta name=twitter:description content="Linux 网络编程 网络字节序 大小端 不同架构的 CPU 中，4 字节整数 1 在内存中存储的方式是不同的。
大端序（big endian）：最高位有效字节存储在低内存地址，而最低位有效字节存储在高内存地址。 小端序（little endian）：最高位有效字节存储在高内存地址，而最低位有效字节存储在低内存地址。 对于一个 4 字节整数 0x01020304，大小端序存储方式分别如下：
地址: 0 1 2 3 （大端序保存） 01 02 03 04 地址: 0 1 2 3 （小端序保存） 04 03 02 01 可以使用下边的方法判断机器的字节序：
通过 endian.h 提供的 BYTE_ORDER 宏。 #include <endian.h> bool big_endian() { return BYTE_ORDER == BIG_ENDIAN; } bool little_endian() { return BYTE_ORDER == LITTLE_ENDIAN; } 将 uint16_t 类型的数字转为 char *，通过高字节和低字节进行判断。 bool big_endian() { uint16_t val = 0x0102; return ((char *) (&amp;val))[0] == 0x01; } bool little_endian() { uint16_t val = 0x0102; return ((char *) (&amp;val))[1] == 0x01; } 和方法 2 类似，利用的是 union 相同的内存位置存储不同的数据类型。 union endian { uint16_t val; char bytes[2]; }; bool big_endian() { union endian en{}; en.val = 0x0102; return en.bytes[0] == 0x01; } bool little_endian() { union endian en{}; en.val = 0x0102; return en.bytes[0] == 0x02; } 为什么有两种不同的字节序？"><link rel=canonical href=https://ileonli.github.io/posts/network-programming/network-programming/><link href=/style.min.2d921c18cf1ec555ffc03d59a8adc211c402c68c930c27d6a0c306ab175a8d09.css rel=stylesheet><link href=/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css rel=stylesheet><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/icons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/icons/favicon-16x16.png><link rel=mask-icon href=/icons/safari-pinned-tab.svg><link rel="shortcut icon" href=/favicon.ico><link rel=manifest href=https://ileonli.github.io/site.webmanifest><meta name=msapplication-config content="/browserconfig.xml"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#434648"><link rel=icon type=image/svg+xml href=/icons/favicon.svg></head><body data-theme=auto class=notransition><script src=/js/theme.min.8961c317c5b88b953fe27525839672c9343f1058ab044696ca225656c8ba2ab0.js integrity="sha256-iWHDF8W4i5U/4nUlg5ZyyTQ/EFirBEaWyiJWVsi6KrA="></script><div class=navbar role=navigation><nav class=menu aria-label="Main Navigation"><a href=https://ileonli.github.io/ class=logo><svg width="25" height="25" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"><title>首页</title><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
</a><input type=checkbox id=menu-trigger class=menu-trigger>
<label for=menu-trigger><span class=menu-icon><svg width="25" height="25" stroke="currentcolor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7H3.40726"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M.5 12.5V1.5c0-.552285.447715-1 1-1h11C13.0523.5 13.5.947715 13.5 1.5v11C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C.947715 13.5.5 13.0523.5 12.5z"/></svg></span></label><div class=trigger><ul class=trigger-container><li><a class=menu-link href=/>首页</a></li><li><a class="menu-link active" href=/posts/>文章</a></li><li><a class=menu-link href=/about/>关于</a></li><li class=menu-separator><span>|</span></li></ul><a id=mode href=#><svg class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg><svg class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg></a></div></nav></div><div class="wrapper post"><main class=page-content aria-label=Content><article><header class=header><h1 class=header-title>Linux 网络编程</h1><div class=post-meta><time datetime=2024-07-10T15:20:00+08:00 itemprop=datePublished>2024年07月10日</time></div></header><details class=toc zgotmplz><summary><b>目录</b></summary><nav id=TableOfContents><ul><li><a href=#网络字节序>网络字节序</a><ul><li><a href=#大小端>大小端</a></li><li><a href=#网络字节序-1>网络字节序</a></li><li><a href=#字节序转换>字节序转换</a></li></ul></li><li><a href=#网络地址族>网络地址族</a><ul><li><a href=#网络地址>网络地址</a><ul><li><a href=#sockaddr_in>sockaddr_in</a></li><li><a href=#sockaddr_in6>sockaddr_in6</a></li></ul></li><li><a href=#in_addr-和-in6_addr>in_addr 和 in6_addr</a><ul><li><a href=#in_addr>in_addr</a></li><li><a href=#in6_addr>in6_addr</a></li></ul></li><li><a href=#网络地址初始化>网络地址初始化</a><ul><li><a href=#ipv4>IPv4</a></li><li><a href=#ipv6>IPv6</a></li></ul></li><li><a href=#思考>思考</a></li></ul></li><li><a href=#套接字socket>套接字（socket）</a><ul><li><a href=#基本函数>基本函数</a><ul><li><a href=#socket>socket</a></li><li><a href=#bind>bind</a></li><li><a href=#listen>listen</a></li><li><a href=#accept>accept</a></li><li><a href=#connect>connect</a></li></ul></li><li><a href=#套接字协议>套接字协议</a><ul><li><a href=#协议族domain>协议族（domain）</a></li><li><a href=#数据传输方式type>数据传输方式（type）</a></li><li><a href=#协议protocol>协议（protocol）</a></li></ul></li></ul></li><li><a href=#io-多路复用>I/O 多路复用</a><ul><li><a href=#select>select</a><ul><li><a href=#函数参数>函数参数</a></li><li><a href=#就绪条件>就绪条件</a></li><li><a href=#循环中使用>循环中使用</a></li></ul></li><li><a href=#poll>poll</a><ul><li><a href=#函数参数-1>函数参数</a></li></ul></li><li><a href=#epoll>epoll</a><ul><li><a href=#epoll_ctl>epoll_ctl</a></li><li><a href=#epoll_wait>epoll_wait</a></li><li><a href=#水平触发和边缘触发>水平触发和边缘触发</a></li></ul></li></ul></li><li><a href=#echo-服务器>echo 服务器</a><ul><li><a href=#辅助函数>辅助函数</a></li><li><a href=#客户端>客户端</a></li><li><a href=#为什么多路复用需要搭配非阻塞>为什么多路复用需要搭配非阻塞</a></li><li><a href=#普通版本>普通版本</a></li><li><a href=#select-版本>select 版本</a></li></ul></li></ul></nav></details><div class=page-content><h1 id=linux-网络编程>Linux 网络编程</h1><h2 id=网络字节序>网络字节序</h2><h3 id=大小端>大小端</h3><p>不同架构的 CPU 中，4 字节整数 1 在内存中存储的方式是不同的。</p><ul><li>大端序（big endian）：<strong>最高位</strong>有效字节存储在<strong>低内存地址</strong>，而<strong>最低位</strong>有效字节存储在<strong>高内存地址</strong>。</li><li>小端序（little endian）：<strong>最高位</strong>有效字节存储在<strong>高内存地址</strong>，而<strong>最低位</strong>有效字节存储在<strong>低内存地址</strong>。</li></ul><hr><p>对于一个 4 字节整数 <code>0x01020304</code>，大小端序存储方式分别如下：</p><pre tabindex=0><code>地址:  0   1   2   3  （大端序保存）
      01  02  03  04
</code></pre><pre tabindex=0><code>地址:  0   1   2   3  （小端序保存）
      04  03  02  01
</code></pre><hr><p>可以使用下边的方法判断机器的字节序：</p><ol><li>通过 <code>endian.h</code> 提供的 <code>BYTE_ORDER</code> 宏。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;endian.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>big_endian</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>BYTE_ORDER</span> <span class=o>==</span> <span class=n>BIG_ENDIAN</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>little_endian</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>BYTE_ORDER</span> <span class=o>==</span> <span class=n>LITTLE_ENDIAN</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=2><li>将 <code>uint16_t</code> 类型的数字转为 <code>char *</code>，通过高字节和低字节进行判断。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>big_endian</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint16_t</span> <span class=n>val</span> <span class=o>=</span> <span class=mh>0x0102</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>val</span><span class=p>))[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=mh>0x01</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>little_endian</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint16_t</span> <span class=n>val</span> <span class=o>=</span> <span class=mh>0x0102</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>val</span><span class=p>))[</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=mh>0x01</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=3><li>和方法 2 类似，利用的是 <code>union</code> 相同的内存位置存储不同的数据类型。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>union</span> <span class=n>endian</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint16_t</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>bytes</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>big_endian</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=n>endian</span> <span class=n>en</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=n>en</span><span class=p>.</span><span class=n>val</span> <span class=o>=</span> <span class=mh>0x0102</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>en</span><span class=p>.</span><span class=n>bytes</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=mh>0x01</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>little_endian</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=n>endian</span> <span class=n>en</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=n>en</span><span class=p>.</span><span class=n>val</span> <span class=o>=</span> <span class=mh>0x0102</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>en</span><span class=p>.</span><span class=n>bytes</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=mh>0x02</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><p>为什么有两种不同的字节序？</p><blockquote><p><strong>大端序</strong>是人类最熟悉的读写方法，从左向右处理。</p><p><strong>小端序</strong>更利于计算机处理，因为计算都是从低位开始的，先处理低位字节，效率比较高。</p></blockquote><h3 id=网络字节序-1>网络字节序</h3><p>如果通信双方采用不同的架构，收发数据后进行解析时会发生问题。如：大端序机器 A 发送 <code>0x01020304</code> 到小端序机器 B 时，B 以小端序方式解析该数字为 <code>0x04030201</code>。</p><p>为解决上边问题，网络传输数据时，通信双方需要约定统一方式，把此约定叫做<strong>网络字节序</strong>（network byte order）。</p><blockquote><p>网络字节序规定使用<strong>大端序</strong>，大多数网络协议（例如 TCP/IP 协议族）规定了网络字节序采用<strong>大端序</strong>。</p></blockquote><p>因此，小端序发送数据时，需要先转为大端序。</p><h3 id=字节序转换>字节序转换</h3><p>下边函数用于字节序的相互转换：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>htonl</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>hostlong</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint16_t</span> <span class=nf>htons</span><span class=p>(</span><span class=kt>uint16_t</span> <span class=n>hostshort</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>ntohl</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>netlong</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint16_t</span> <span class=nf>ntohs</span><span class=p>(</span><span class=kt>uint16_t</span> <span class=n>netshort</span><span class=p>);</span>
</span></span></code></pre></div><p>函数名中的 <code>h</code> 表示主机（host）字节序，<code>n</code> 表示网络（network）字节序；<code>s</code> 表示 <code>short</code> 类型，<code>l</code> 表示 <code>long</code> 类型。</p><h2 id=网络地址族>网络地址族</h2><h3 id=网络地址>网络地址</h3><p>网络地址分为 IPv4 和 IPv6，分别使用 <code>sockaddr_in</code> 和 <code>sockaddr_in6</code> 结构体表示。</p><h4 id=sockaddr_in>sockaddr_in</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sa_family_t</span>    <span class=n>sin_family</span><span class=p>;</span> <span class=cm>/* address family: AF_INET */</span>
</span></span><span class=line><span class=cl>    <span class=kt>in_port_t</span>      <span class=n>sin_port</span><span class=p>;</span>   <span class=cm>/* port in network byte order */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>in_addr</span> <span class=n>sin_addr</span><span class=p>;</span>   <span class=cm>/* internet address */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Pad to size of `struct sockaddr&#39;.  */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>sin_zero</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Internet address */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>in_addr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span>       <span class=n>s_addr</span><span class=p>;</span>     <span class=cm>/* address in network byte order */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li><code>sin_family</code>：在 IPv4 中设为 <code>AF_INET</code>。</li><li><code>sin_port</code>：<strong>网络字节序</strong>保存的端口（0～65535）。</li><li><code>sin_addr</code>：<strong>网络字节序</strong>保存的 32 位 IP 地址信息。</li><li><code>sin_zero</code>：使 <code>sockaddr_in</code> 和 <code>sockaddr</code> 结构体大小保持一致而插入的填充位，需手动设为 0。</li></ul><blockquote><p><a href=https://man7.org/linux/man-pages/man7/ip.7.html>https://man7.org/linux/man-pages/man7/ip.7.html</a></p></blockquote><h4 id=sockaddr_in6>sockaddr_in6</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sa_family_t</span>     <span class=n>sin6_family</span><span class=p>;</span>   <span class=cm>/* AF_INET6 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>in_port_t</span>       <span class=n>sin6_port</span><span class=p>;</span>     <span class=cm>/* port number */</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span>        <span class=n>sin6_flowinfo</span><span class=p>;</span> <span class=cm>/* IPv6 flow information */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>in6_addr</span> <span class=n>sin6_addr</span><span class=p>;</span>     <span class=cm>/* IPv6 address */</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span>        <span class=n>sin6_scope_id</span><span class=p>;</span> <span class=cm>/* Scope ID (new in Linux 2.4) */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>in6_addr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span>   <span class=n>s6_addr</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>   <span class=cm>/* IPv6 address */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li><code>sin6_family</code>：在 IPv6 中总设为 <code>AF_INET6</code>。</li><li><code>sin6_port</code>：<strong>网络字节序</strong>保存的端口（0～65535）。</li><li><code>sin6_flowinfo</code>：IPv6 流信息（不广泛使用）。</li><li><code>sin6_addr</code>：表示 IPv6 地址的结构体，定义为 <code>struct in6_addr</code>。</li><li><code>sin6_scope_id</code>：范围标识符（用于链路本地和站点本地地址）。</li></ul><blockquote><p><a href=https://man7.org/linux/man-pages/man7/ipv6.7.html>https://man7.org/linux/man-pages/man7/ipv6.7.html</a></p></blockquote><h3 id=in_addr-和-in6_addr>in_addr 和 in6_addr</h3><h4 id=in_addr>in_addr</h4><p>我们比较熟悉的 IPv4 地址表示方法为<strong>点分十进制表示法</strong>，如：201.123.235.213。</p><p>而 <code>in_addr</code> 结构体使用 <code>uint32_t</code> 保存 IPv4 地址，我们需要将字符串形式的 IPv4 地址转为 32 位整数表示。</p><hr><p><code>inet_addr</code> 函数可用于转换，该函数在转换的同时会进行网络字节序的转换。</p><p><code>inet_ntoa</code> 函数则相反，将 <code>in_addr</code> 结构体转为字符串。</p><p><strong>注意：</strong><code>inet_ntoa</code> 函数返回的是一个指向静态缓冲区的指针，最好将返回值拷贝到其它地方，以免被覆盖。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>in_addr_t</span> <span class=nf>inet_addr</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>cp</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=nf>inet_ntoa</span><span class=p>(</span><span class=k>struct</span> <span class=n>in_addr</span> <span class=n>in</span><span class=p>);</span>
</span></span></code></pre></div><p>也可以使用 <code>inet_aton</code> 函数，该函数将结果直接保存到传入的 <code>inp</code> 结构体中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>inet_aton</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>cp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>in_addr</span> <span class=o>*</span><span class=n>inp</span><span class=p>);</span>
</span></span></code></pre></div><h4 id=in6_addr>in6_addr</h4><p><code>sockaddr_in5</code> 结构体中的 <code>in6_addr</code> 结构体包含一个 <code>unsigned char</code> 类型的成员 <code>s6_addr</code>，用于存储 128 位的 IPv6 地址。</p><p><code>inet_pton</code> 函数中的 <code>af</code> 参数必须为 <code>AF_INET</code> 和 <code>AF_INET6</code>，分别处理 IPv4 和 IPv6 协议。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>inet_pton</span><span class=p>(</span><span class=kt>int</span> <span class=n>af</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>src</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>dst</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>inet_ntop</span><span class=p>(</span><span class=kt>int</span> <span class=n>af</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>src</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=kt>char</span> <span class=n>dst</span><span class=p>[</span><span class=kr>restrict</span> <span class=p>.</span><span class=n>size</span><span class=p>],</span> <span class=kt>socklen_t</span> <span class=n>size</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=网络地址初始化>网络地址初始化</h3><h4 id=ipv4>IPv4</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>address</span> <span class=o>=</span> <span class=s>&#34;211.123.211.168&#34;</span><span class=p>;</span> <span class=c1>// IP 地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>port</span> <span class=o>=</span> <span class=s>&#34;7890&#34;</span><span class=p>;</span>               <span class=c1>// 端口
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>addr</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>addr</span><span class=p>.</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>                 <span class=c1>// IPv4;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addr</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=nf>inet_addr</span><span class=p>(</span><span class=n>address</span><span class=p>);</span> <span class=c1>// 设置 IP 地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addr</span><span class=p>.</span><span class=n>sin_port</span> <span class=o>=</span> <span class=nf>htons</span><span class=p>(</span><span class=nf>atoi</span><span class=p>(</span><span class=n>port</span><span class=p>));</span>         <span class=c1>// 以网络字节序设置端口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h4 id=ipv6>IPv6</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>address</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>        <span class=s>&#34;2001:0db8:85a3:0000:0000:8a2e:0370:7334&#34;</span><span class=p>;</span> <span class=c1>// IPv6 地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>port</span> <span class=o>=</span> <span class=s>&#34;7890&#34;</span><span class=p>;</span>                     <span class=c1>// 端口
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>addr</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>addr</span><span class=p>.</span><span class=n>sin6_family</span> <span class=o>=</span> <span class=n>AF_INET6</span><span class=p>;</span>                   <span class=c1>// IPv6
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>inet_pton</span><span class=p>(</span><span class=n>AF_INET6</span><span class=p>,</span> <span class=n>address</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addr</span><span class=p>.</span><span class=n>sin6_addr</span><span class=p>);</span> <span class=c1>// 设置 IP 地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addr</span><span class=p>.</span><span class=n>sin6_port</span> <span class=o>=</span> <span class=nf>htons</span><span class=p>(</span><span class=nf>atoi</span><span class=p>(</span><span class=n>port</span><span class=p>));</span>            <span class=c1>// 以网络字节序设置端口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=思考>思考</h3><p>为什么 <code>sockaddr_in</code> 和 <code>sockaddr_in6</code> 分别表示 IPv4 和 IPv6 协议，还要额外使用 <code>sa_family_t</code> 指定协议版本呢？</p><blockquote><p>因为 <code>connect</code>、<code>bind</code>、和 <code>accept</code> 函数第二个参数都接收 <code>sockaddr</code> 结构体。因此，需要使用 <code>sa_family</code> 用于区分不同版本的协议。通过使用通用的 <code>sockaddr</code> 结构体，该函数不仅可以处理 IPv4 和 IPv6 协议，还可处理其它协议。这样，就不需要为每种协议都提供对应的函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sa_family_t</span>     <span class=n>sa_family</span><span class=p>;</span>      <span class=cm>/* Address family */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>            <span class=n>sa_data</span><span class=p>[];</span>      <span class=cm>/* Socket address */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div></blockquote><h2 id=套接字socket>套接字（socket）</h2><p><strong>网络编程</strong>即编写程序使两台联网的计算机相互交换数据。计算机之间会通过网线、路由器和交换机等设备连接在一起，我们无需直接操控硬件，而使用操作系统提供的<strong>套接字（socket）</strong>。</p><h3 id=基本函数>基本函数</h3><h4 id=socket>socket</h4><p>为了使用套接字，可以使用 <code>socket</code> 函数，创建用于通信的端点（endpoint）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>socket</span><span class=p>(</span><span class=kt>int</span> <span class=n>domain</span><span class=p>,</span> <span class=kt>int</span> <span class=n>type</span><span class=p>,</span> <span class=kt>int</span> <span class=n>protocol</span><span class=p>);</span>
</span></span></code></pre></div><p><strong>成功时</strong>会返回文件描述符，<strong>失败时</strong>会返回 -1。</p><blockquote><p><a href=https://man7.org/linux/man-pages/man2/socket.2.html>https://man7.org/linux/man-pages/man2/socket.2.html</a></p></blockquote><h4 id=bind>bind</h4><p>当使用 <code>socket</code> 函数创建套接字后，会存在于名称空间（地址族）中，但没有为其分配地址。<code>bind</code> 函数将 <code>addr</code> 指定的地址分配给文件描述符 <code>sockfd</code> 引用的套接字。</p><p>服务器可以不先调用 <code>bind()</code> 而直接调用 <code>listen()</code>，此时会为该 <code>socket</code> 分配一个 <strong><code>INADDR_ANY</code> IP 地址</strong>（0.0.0.0）和<strong>临时端口</strong>（可通过 <code>getsockname()</code> 获取 <code>socket</code> 的地址）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>bind</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=kt>socklen_t</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span></code></pre></div><p><strong>成功时</strong>返回 0，<strong>失败时</strong>返回 -1。</p><blockquote><p><a href=https://man7.org/linux/man-pages/man2/bind.2.html>https://man7.org/linux/man-pages/man2/bind.2.html</a></p></blockquote><h4 id=listen>listen</h4><p><code>listen</code> 函数将文件描述符引用的 <code>socket</code> 标记为被动，该 <code>socket</code> 会被用来接受来自其它主动 <code>socket</code> 的连接。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>listen</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>backlog</span><span class=p>);</span>
</span></span></code></pre></div><p><strong>成功时</strong>返回 0，<strong>失败时</strong>返回 -1。</p><blockquote><p><a href=https://man7.org/linux/man-pages/man2/listen.2.html>https://man7.org/linux/man-pages/man2/listen.2.html</a></p></blockquote><h4 id=accept>accept</h4><p>执行 <code>accept</code> 函数会创建一个新的 <code>socket</code>，此 <code>socket</code> 会与执行 <code>connect</code> 函数的 <code>socket</code> 进行连接。此函数调用返回值是已连接的 <code>socket</code> 的文件描述符。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>accept</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>_Nullable</span> <span class=kr>restrict</span> <span class=n>addr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=kt>socklen_t</span> <span class=o>*</span><span class=n>_Nullable</span> <span class=kr>restrict</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span></code></pre></div><p><strong>成功时</strong>会返回文件描述符，<strong>失败时</strong>会返回 -1。</p><blockquote><p><a href=https://man7.org/linux/man-pages/man2/accept.2.html>https://man7.org/linux/man-pages/man2/accept.2.html</a></p></blockquote><h4 id=connect>connect</h4><p><code>connect</code> 函数将文件描述符 <code>sockfd</code> 引用的套接字连接到由 <code>addr</code> 指定的地址。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>connect</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=kt>socklen_t</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span></code></pre></div><blockquote><p><a href=https://man7.org/linux/man-pages/man2/connect.2.html>https://man7.org/linux/man-pages/man2/connect.2.html</a></p></blockquote><h3 id=套接字协议>套接字协议</h3><p><code>socket</code> 函数（<code>int socket(int domain, int type, int protocol)</code>）有三个参数用于选择传输协议和方式。</p><h4 id=协议族domain>协议族（domain）</h4><p>所有的协议族可以点击 <a href=https://man7.org/linux/man-pages/man7/address_families.7.html>address_families</a> 查看，主要的协议族分类如下：</p><table><thead><tr><th>协议族</th><th>描述</th></tr></thead><tbody><tr><td>AF_INET</td><td>使用 IPv4 地址</td></tr><tr><td>AF_INET6</td><td>使用 IPv6 地址</td></tr><tr><td>AF_UNIX</td><td>本地通信，用于同一台机器上的进程间通信</td></tr><tr><td>AF_PACKET</td><td>原始数据包捕获和注入，需要特殊权限</td></tr><tr><td>AF_NETLINK</td><td>用于 Linux 内核与用户空间进程之间的通信</td></tr></tbody></table><hr><p><code>AF_常量</code> 和 <code>PF_常量</code> 的区别？</p><blockquote><p>AF 表示地址族（address family），PF 表示协议族（protocol family）。在一开始的时候，设计人员相信单个协议族可以支持多个地址族。但在实践中，没有哪一个协议族能够支持多个已经被定义的地址族，并且所有既有实现都将 <code>PF_常量</code> 定义成对应的 <code>AF_常量</code> 的同义词。</p></blockquote><h4 id=数据传输方式type>数据传输方式（type）</h4><p>数据传输类型主要有以下两种：</p><ul><li><strong>面向连接</strong>的套接字（SOCK_STREAM）：提供有序的、可靠的、双向的、基于连接的字节流。可以支持带外（<a href=https://en.wikipedia.org/wiki/Out-of-band_data>out-of-band</a>）数据传输机制。</li><li><strong>面向消息</strong>的套接字（SOCK_DGRAM）：支持数据报（无连接、最大长度固定的不可靠消息）。</li></ul><h4 id=协议protocol>协议（protocol）</h4><p>在给定的协议族中，通常只有一个协议存在以支持特定的套接字类型，在这种情况下，可以将 <code>protocol</code> 指定为 0。</p><p>在大部分情况下，第三个参数传递 0 即可。然而，协议族下可能存在许多协议，在这种情况下，必须使用 <code>protocol</code> 指定一个特定的协议。</p><h2 id=io-多路复用>I/O 多路复用</h2><p>I/O 复用可以使程序同时监听多个文件描述符。</p><h3 id=select>select</h3><p><code>select</code> 函数允许程序监视多个文件描述符，直到一个或多个文件描述符“准备好”进行某类 I/O 操作。</p><p><code>select</code> 成功时返回就绪文件描述符的总数，如果超时时间内没有任何文件描述符就绪，则返回 0。失败时返回 -1 并设置 <code>errno</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/select.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>select</span><span class=p>(</span><span class=kt>int</span> <span class=n>nfds</span><span class=p>,</span> <span class=n>fd_set</span><span class=o>*</span> <span class=n>readfds</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>fd_set</span><span class=o>*</span> <span class=n>writefds</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>fd_set</span><span class=o>*</span> <span class=n>exceptfds</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>struct</span> <span class=n>timeval</span> <span class=o>*</span> <span class=n>timeout</span><span class=p>);</span>
</span></span></code></pre></div><h4 id=函数参数>函数参数</h4><p><code>nfds</code>：指定被监听的文件描述符的总数。这个参数应该被设置为三个集合中编号最高的文件描述符，再加 1，因为文件描述符是从 0 开始的。</p><hr><p><code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code>：分别指向可读、可写和异常事件对应的文件描述符集合。如果没有文件描述符要监听，则可以将对应的 <code>fd_set</code> 参数设为 <code>NULL</code>。</p><p><code>fd_set</code> 结构体仅包含一个数组，数组每一位标记一个文件描述符，最大容纳长度由 <code>FD_SETSIZE</code> 指定。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* fd_set for select and pselect.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* XPG4.2 requires this member name.  Otherwise avoid the name
</span></span></span><span class=line><span class=cl><span class=cm>       from the global namespace.  */</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __USE_XOPEN
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>__fd_mask</span> <span class=n>fds_bits</span><span class=p>[</span><span class=n>__FD_SETSIZE</span> <span class=o>/</span> <span class=n>__NFDBITS</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=cp># define __FDS_BITS(set) ((set)-&gt;fds_bits)
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>__fd_mask</span> <span class=n>__fds_bits</span><span class=p>[</span><span class=n>__FD_SETSIZE</span> <span class=o>/</span> <span class=n>__NFDBITS</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=cp># define __FDS_BITS(set) ((set)-&gt;__fds_bits)
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=p>}</span> <span class=n>fd_set</span><span class=p>;</span>
</span></span></code></pre></div><p>为方便对此结构体进行操作，提供了以下几个宏函数对其进行操作，宏函数如下：</p><blockquote><p>为方便展示，对宏函数中的所有参数加上了类型</p></blockquote><ul><li><code>FD_SET(fd, fdsetp)</code>：将文件描述符 <code>fd</code> 添加到 <code>fdset</code> 指向的集合中。</li><li><code>FD_CLR(fd, fdsetp)</code>：将文件描述符 <code>fd</code> 从 <code>fdset</code> 指向的集合中移除。</li><li><code>FD_ISSET(fd, fdsetp)</code>：如果文件描述符 <code>fd</code> 是 <code>fdset</code> 指向的集合中的成员，则返回 <code>true</code>。</li><li><code>FD_ZERO(fdsetp)</code>：将 <code>fdset</code> 指向的集合初始化为空。</li></ul><hr><p><code>timeval</code>：用来设置 <code>select</code> 函数的超时时间，采用指针作为参数是因为内核将修改以告诉应用程序 select 等待了多久。</p><p>如果 <code>timeval</code> 结构体中的 <code>tv_sec</code> 和 <code>tv_usec</code> 成员都传递 0，则 <code>select</code> 函数立即返回。如果传递 <code>NULL</code>，则一直阻塞，直到某个文件描述符就绪。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* A time value that is accurate to the nearest
</span></span></span><span class=line><span class=cl><span class=cm>   microsecond but also has a range of years.  */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>timeval</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __USE_TIME_BITS64
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=n>__time64_t</span> <span class=n>tv_sec</span><span class=p>;</span>		<span class=cm>/* Seconds.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>__suseconds64_t</span> <span class=n>tv_usec</span><span class=p>;</span>	<span class=cm>/* Microseconds.  */</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=n>__time_t</span> <span class=n>tv_sec</span><span class=p>;</span>		<span class=cm>/* Seconds.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>__suseconds_t</span> <span class=n>tv_usec</span><span class=p>;</span>	<span class=cm>/* Microseconds.  */</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>};</span>
</span></span></code></pre></div><h4 id=就绪条件>就绪条件</h4><p>在网络编程中，下边情况下 <code>socket</code> 可读：</p><p>在网络编程中，下边情况下 <code>socket</code> 可写：</p><p><code>select</code> 函数能处理的异常情况只有一种：<code>socket</code> 上接收到带外数据。</p><h4 id=循环中使用>循环中使用</h4><p>由于这些结构体会在调用中被修改，如果要在循环中重复调用 <code>select</code> 函数，我们必须保证每次都要重新初始化它们。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C></code></pre></div><h3 id=poll>poll</h3><p><code>poll</code> 函数和 <code>select</code> 函数调用返回值一致。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;poll.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>poll</span><span class=p>(</span><span class=k>struct</span> <span class=n>pollfd</span> <span class=o>*</span><span class=n>fds</span><span class=p>,</span> <span class=kt>nfds_t</span> <span class=n>nfds</span><span class=p>,</span> <span class=kt>int</span> <span class=n>timeout</span><span class=p>);</span>
</span></span></code></pre></div><h4 id=函数参数-1>函数参数</h4><p><code>fds</code>：需要 <code>poll</code> 函数检查的文件描述符，该参数为 <code>pollfd</code> 结构体数组。</p><p><code>pollfd</code> 结构体中 <code>fd</code> 指定文件描述符；<code>events</code> 告诉 <code>poll</code> 函数需要监听哪些事件；<code>revents</code> 由内核对其进行修改，以通知应用程序 <code>fd</code> 上实际发生了哪些事件。</p><table><thead><tr><th>位掩码</th><th>events</th><th>返回到revents</th><th>描述</th></tr></thead><tbody><tr><td>POLLIN</td><td>●</td><td>●</td><td>可读取非高优先级的数据</td></tr><tr><td>POLLRDNORM</td><td>●</td><td>●</td><td>等同于POLLIN</td></tr><tr><td>POLLRDBAND</td><td>●</td><td>●</td><td>可读取优先级数据（Linux 中不使用）</td></tr><tr><td>POLLPRI</td><td>●</td><td>●</td><td>可读取高优先级数据</td></tr><tr><td>POLLRDHUP</td><td>●</td><td>●</td><td>对端套接字关闭</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>POLLOUT</td><td>●</td><td>●</td><td>普通数据可写</td></tr><tr><td>POLLWRNORM</td><td>●</td><td>●</td><td>等同于POLLOUT</td></tr><tr><td>POLLWRBAND</td><td>●</td><td>●</td><td>优先级数据可写入</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>POLLERR</td><td></td><td>●</td><td>有错误发生</td></tr><tr><td>POLLHUP</td><td></td><td>●</td><td>出现挂断</td></tr><tr><td>POLLNVAL</td><td></td><td>●</td><td>文件描述符未打开</td></tr><tr><td>POLLMSG</td><td></td><td></td><td>Linux 中不使用</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>pollfd</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>   <span class=n>fd</span><span class=p>;</span>         <span class=cm>/* file descriptor */</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span> <span class=n>events</span><span class=p>;</span>     <span class=cm>/* requested events */</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span> <span class=n>revents</span><span class=p>;</span>    <span class=cm>/* returned events */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><hr><p><code>nfds</code>：用于指定数组 <code>fds</code> 中元素的个数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* Type used for the number of file descriptors.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span> <span class=kt>nfds_t</span><span class=p>;</span>
</span></span></code></pre></div><hr><p><code>timeout</code>：指定 <code>poll</code> 的超时值，单位为毫秒。</p><ul><li>当 <code>timeout</code> 为 -1 时，<code>poll</code> 调用将一直阻塞，直到某个事件发生；</li><li>当 <code>timeout</code> 为 0 时，<code>poll</code> 调用将立即返回。</li></ul><h3 id=epoll>epoll</h3><p><code>epoll</code> 是 Linux 特有的 I/O 复用函数。<code>epoll</code> 需要使用额外的文件描述符，标识内核中的这个事件表，需要使用 <code>epoll_create</code> 函数创建，返回文件描述符。</p><p><code>size</code> 是想要通过 <code>epoll</code> 来检查的文件描述符个数。该参数并不是一个上限，而是告诉内核应该如何为内部数据结构划分初始大小（从 Linux 2.6.8 版以来，<code>size</code> 参数被忽略不用，因为内核实现做了修改意味着该参数提供的信息已经不再需要了）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/epoll.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_create</span> <span class=p>(</span><span class=kt>int</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_create1</span> <span class=p>(</span><span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span></code></pre></div><h4 id=epoll_ctl>epoll_ctl</h4><p><code>epoll_ctl</code> 函数能够修改由文件描述符 <code>epfd</code> 所代表的兴趣列表。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_ctl</span> <span class=p>(</span><span class=kt>int</span> <span class=n>epfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>op</span><span class=p>,</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		      <span class=k>struct</span> <span class=n>epoll_event</span> <span class=o>*</span><span class=n>event</span><span class=p>);</span>
</span></span></code></pre></div><hr><p><code>epfd</code> 是调用 <code>epoll_create</code> 函数的返回值。</p><hr><p><code>op</code> 用于操作操作类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* Valid opcodes ( &#34;op&#34; parameter ) to issue to epoll_ctl().  */</span>
</span></span><span class=line><span class=cl><span class=cp>#define EPOLL_CTL_ADD 1	</span><span class=cm>/* Add a file descriptor to the interface.  */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define EPOLL_CTL_DEL 2	</span><span class=cm>/* Remove a file descriptor from the interface.  */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define EPOLL_CTL_MOD 3	</span><span class=cm>/* Change file descriptor epoll_event structure.  */</span><span class=cp>
</span></span></span></code></pre></div><hr><p><code>events</code> 是一个位掩码，指定了待检查描述符 <code>fd</code> 上感兴趣的事件集合。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>epoll_event</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>events</span><span class=p>;</span>	 <span class=cm>/* Epoll events */</span>
</span></span><span class=line><span class=cl>  <span class=kt>epoll_data_t</span> <span class=n>data</span><span class=p>;</span> <span class=cm>/* User data variable */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>data</code> 当描述符 <code>fd</code> 就绪时，传递给调用者的信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>typedef</span> <span class=k>union</span> <span class=n>epoll_data</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>u32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>u64</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>epoll_data_t</span><span class=p>;</span>
</span></span></code></pre></div><h4 id=epoll_wait>epoll_wait</h4><p>返回 <code>epoll</code> 实例中处于就绪态的文件描述符信息。单个 <code>epoll_wait</code> 函数调用能返回多个就绪态文件描述符的信息。</p><p>调用成功后，<code>epoll_wait</code> 函数返回数组 <code>events</code> 元素个数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_wait</span> <span class=p>(</span><span class=kt>int</span> <span class=n>epfd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>epoll_event</span> <span class=o>*</span><span class=n>events</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		       <span class=kt>int</span> <span class=n>maxevents</span><span class=p>,</span> <span class=kt>int</span> <span class=n>timeout</span><span class=p>);</span>
</span></span></code></pre></div><hr><p><code>events</code> 所指向的结构体数组中返回的是有关就绪态文件描述符的信息。</p><p>数组 <code>events</code> 的空间由调用者负责申请，所包含的元素个数由参数 <code>maxevents</code> 指定。</p><hr><p><code>timeout</code>：指定 <code>epoll</code> 的超时值，单位为毫秒。</p><ul><li>当 <code>timeout</code> 为 -1 时，<code>epoll</code> 调用将一直阻塞，直到某个事件发生；</li><li>当 <code>timeout</code> 为 0 时，<code>epoll</code> 执行一次非阻塞式的检查，看兴趣列表中的文件描述符上产生了哪个事件。</li><li>当 <code>timeout</code> 大于 0 时，<code>epoll</code> 阻塞至多 <code>timeout</code> 毫秒，直到文件描述符上有事件发生，或者直到捕获到一个信号为止。</li></ul><h4 id=水平触发和边缘触发>水平触发和边缘触发</h4><p><code>epoll</code> 默认工作模式为<strong>水平触发</strong>，当往 <code>epoll</code> 内核事件表中注册一个文件描述符上的 <code>EPOLLET</code> 事件时，将以<strong>边缘触发</strong>模式工作。</p><ul><li><p>LT 模式（水平）：缓冲区剩余未读尽的数据<strong>会</strong>导致 <code>epoll_wait</code> 返回。直到新的事件满足才会触发。支持阻塞和非阻塞。</p></li><li><p>ET 模式（边缘）：缓冲区剩余未读尽的数据<strong>不会</strong>导致 <code>epoll_wait</code> 返回。必须设置为非阻塞。</p></li></ul><h2 id=echo-服务器>echo 服务器</h2><h3 id=辅助函数>辅助函数</h3><p><code>panic</code> 函数用于错误处理，当发生错误时，调用 <code>exit</code> 函数直接退出程序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>panic</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>format</span><span class=p>,</span> <span class=p>...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>va_list</span> <span class=n>args</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>va_start</span><span class=p>(</span><span class=n>args</span><span class=p>,</span> <span class=n>format</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>vfprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=n>format</span><span class=p>,</span> <span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>va_end</span><span class=p>(</span><span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>readn</code> 和 <code>writen</code> 函数分别用于从 <code>fd</code> 处读和写 <code>n</code> 个字节。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>readn</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>ssize_t</span> <span class=n>nread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>nleft</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>nread</span> <span class=o>=</span> <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>nleft</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>nleft</span> <span class=o>==</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=c1>// error, return -1
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span> <span class=c1>// error, return amount read so far
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>nleft</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>nread</span> <span class=o>=</span> <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>nleft</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>nleft</span> <span class=o>==</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=c1>// error, return -1
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>nleft</span> <span class=o>-=</span> <span class=n>nread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span> <span class=o>+=</span> <span class=n>nread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>n</span> <span class=o>-</span> <span class=n>nleft</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>writen</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span> <span class=n>nleft</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>ssize_t</span> <span class=n>nwritten</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>nleft</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>nwritten</span> <span class=o>=</span> <span class=nf>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>nleft</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>nleft</span> <span class=o>==</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>nwritten</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>nleft</span> <span class=o>-=</span> <span class=n>nwritten</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span> <span class=o>+=</span> <span class=n>nwritten</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>n</span> <span class=o>-</span> <span class=n>nleft</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>read_line</code> 函数用于从用户处读取一行输入。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=nf>read_line</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>line</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span> <span class=n>buf_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>ssize_t</span> <span class=n>n_bytes</span> <span class=o>=</span> <span class=nf>getline</span><span class=p>(</span><span class=o>&amp;</span><span class=n>line</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>buf_size</span><span class=p>,</span> <span class=n>stdin</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>n_bytes</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;error: reading input</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>line</span><span class=p>[</span><span class=n>n_bytes</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;\n&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>line</span><span class=p>[</span><span class=n>n_bytes</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>line</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>set_nonblocking</code> 函数用于将 <code>fd</code> 设为非阻塞模式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>set_nonblocking</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>flags</span> <span class=o>=</span> <span class=nf>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_GETFL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>flags</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>||</span> <span class=nf>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_SETFL</span><span class=p>,</span> <span class=n>flags</span> <span class=o>|</span> <span class=n>O_NONBLOCK</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>create_sockaddr_in</code> 函数用于创建 <code>struct sockaddr_in</code> 结构体。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span><span class=nf>create_sockaddr_in</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>address</span><span class=p>,</span> <span class=kt>int</span> <span class=n>port</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span><span class=n>addr</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_in</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>addr</span><span class=o>-&gt;</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>addr</span><span class=o>-&gt;</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=nf>inet_addr</span><span class=p>(</span><span class=n>address</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>addr</span><span class=o>-&gt;</span><span class=n>sin_port</span> <span class=o>=</span> <span class=nf>htons</span><span class=p>(</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于 <code>socket</code>、<code>bind</code>、<code>listen</code>、<code>accept</code> 和 <code>connect</code> 函数，大部分使用都是一样的，对其进行封装。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Socket</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;socket() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Bind</span><span class=p>(</span><span class=kt>int</span> <span class=n>socket_fd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span><span class=n>addr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>bind</span><span class=p>(</span><span class=n>socket_fd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)(</span><span class=n>addr</span><span class=p>),</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;bind() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Listen</span><span class=p>(</span><span class=kt>int</span> <span class=n>socket_fd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>listen</span><span class=p>(</span><span class=n>socket_fd</span><span class=p>,</span> <span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;listen() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Accept</span><span class=p>(</span><span class=kt>int</span> <span class=n>socket_fd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=o>*</span><span class=n>addr_len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>accept</span><span class=p>(</span><span class=n>socket_fd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=n>addr</span><span class=p>,</span> <span class=n>addr_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;accept() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>set_nonblocking</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;set_nonblocking error</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Connect</span><span class=p>(</span><span class=kt>int</span> <span class=n>socket_fd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span><span class=n>addr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>connect</span><span class=p>(</span><span class=n>socket_fd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)(</span><span class=n>addr</span><span class=p>),</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;connect() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=客户端>客户端</h3><p>客户端读取一行用户的输入，将数据传给服务器，服务器将所有的字母大写后再传给客户端。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>run_client</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>remote_address</span><span class=p>,</span> <span class=kt>int</span> <span class=n>remote_port</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>client_fd</span> <span class=o>=</span> <span class=nf>Socket</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span><span class=n>server_addr</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=nf>create_sockaddr_in</span><span class=p>(</span><span class=n>remote_address</span><span class=p>,</span> <span class=n>remote_port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>Connect</span><span class=p>(</span><span class=n>client_fd</span><span class=p>,</span> <span class=n>server_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>input</span> <span class=o>=</span> <span class=nf>read_line</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>input_len</span> <span class=o>=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>input_len</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>input_len</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=n>sent_bytes</span> <span class=o>=</span> <span class=nf>send</span><span class=p>(</span><span class=n>client_fd</span><span class=p>,</span> <span class=n>input</span><span class=p>,</span> <span class=n>input_len</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sent_bytes</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;send() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=n>recv_bytes</span> <span class=o>=</span> <span class=nf>recv</span><span class=p>(</span><span class=n>client_fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>input_len</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>recv_bytes</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;recv() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nl>out</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=为什么多路复用需要搭配非阻塞>为什么多路复用需要搭配非阻塞</h3><pre tabindex=0><code>On Linux, select() may report a socket file descriptor as &#34;ready
for reading&#34;, while nevertheless a subsequent read blocks.  This
could for example happen when data has arrived but upon
examination has the wrong checksum and is discarded.  There may
be other circumstances in which a file descriptor is spuriously
reported as ready.  Thus it may be safer to use O_NONBLOCK on
sockets that should not block.
</code></pre><p>参考链接：<a href="https://man7.org/linux/man-pages/man2/select.2.html#:~:text=On%20Linux%2C%20select%28%29%20may,sockets%20that%20should%20not%20block.">select</a></p><h3 id=普通版本>普通版本</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;ctype.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdarg.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>used_for_cleanup_fd</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>panic</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>format</span><span class=p>,</span> <span class=p>...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>va_list</span> <span class=n>args</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>va_start</span><span class=p>(</span><span class=n>args</span><span class=p>,</span> <span class=n>format</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>vfprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=n>format</span><span class=p>,</span> <span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>va_end</span><span class=p>(</span><span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cleanup</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>used_for_cleanup_fd</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>used_for_cleanup_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>run_client</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>remote_address</span><span class=p>,</span> <span class=kt>int</span> <span class=n>remote_port</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>512</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>client_fd</span> <span class=o>=</span> <span class=nf>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>client_fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;socket() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>atexit</span><span class=p>(</span><span class=n>cleanup</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>used_for_cleanup_fd</span> <span class=o>=</span> <span class=n>client_fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>server_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>server_addr</span><span class=p>.</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>server_addr</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=nf>inet_addr</span><span class=p>(</span><span class=n>remote_address</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>server_addr</span><span class=p>.</span><span class=n>sin_port</span> <span class=o>=</span> <span class=nf>htons</span><span class=p>(</span><span class=n>remote_port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ret</span> <span class=o>=</span> <span class=nf>connect</span><span class=p>(</span><span class=n>client_fd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>server_addr</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                <span class=k>sizeof</span><span class=p>(</span><span class=n>server_addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;connect() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fgets</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>),</span> <span class=n>stdin</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span><span class=p>[</span><span class=nf>strcspn</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>buf_len</span> <span class=o>=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>buf_len</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>buf_len</span> <span class=o>&gt;=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;input too long</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=n>sent_bytes</span> <span class=o>=</span> <span class=nf>send</span><span class=p>(</span><span class=n>client_fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>buf_len</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sent_bytes</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;send() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=n>recv_bytes</span> <span class=o>=</span> <span class=nf>recv</span><span class=p>(</span><span class=n>client_fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>recv_bytes</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;recv() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>run_server</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>address</span><span class=p>,</span> <span class=kt>int</span> <span class=n>port</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>512</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>server_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>server_addr</span><span class=p>.</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>server_addr</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=nf>inet_addr</span><span class=p>(</span><span class=n>address</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>server_addr</span><span class=p>.</span><span class=n>sin_port</span> <span class=o>=</span> <span class=nf>htons</span><span class=p>(</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>server_fd</span> <span class=o>=</span> <span class=nf>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>server_fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;socket() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nf>atexit</span><span class=p>(</span><span class=n>cleanup</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>used_for_cleanup_fd</span> <span class=o>=</span> <span class=n>server_fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ret</span> <span class=o>=</span> <span class=nf>bind</span><span class=p>(</span><span class=n>server_fd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>server_addr</span><span class=p>),</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>server_addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;bind() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ret</span> <span class=o>=</span> <span class=nf>listen</span><span class=p>(</span><span class=n>server_fd</span><span class=p>,</span> <span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;listen() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>client_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>socklen_t</span> <span class=n>client_addr_len</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>client_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>client_fd</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=nf>accept</span><span class=p>(</span><span class=n>server_fd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>client_addr</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>client_addr_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>client_fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;accept() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>ssize_t</span> <span class=n>read_bytes</span> <span class=o>=</span> <span class=nf>recv</span><span class=p>(</span><span class=n>client_fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>read_bytes</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;recv() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>read_bytes</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>client_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>ssize_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>read_bytes</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=p>)</span><span class=nf>toupper</span><span class=p>((</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=p>)</span><span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=kt>ssize_t</span> <span class=n>sent_bytes</span> <span class=o>=</span> <span class=nf>send</span><span class=p>(</span><span class=n>client_fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>read_bytes</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>sent_bytes</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;send() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;usage: &lt;mode&gt; &lt;IP&gt; &lt;port&gt;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>mode</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>address</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>port</span> <span class=o>=</span> <span class=nf>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>3</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>strncmp</span><span class=p>(</span><span class=n>mode</span><span class=p>,</span> <span class=s>&#34;client&#34;</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>run_client</span><span class=p>(</span><span class=n>address</span><span class=p>,</span> <span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>strncmp</span><span class=p>(</span><span class=n>mode</span><span class=p>,</span> <span class=s>&#34;server&#34;</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>run_server</span><span class=p>(</span><span class=n>address</span><span class=p>,</span> <span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=select-版本>select 版本</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;ctype.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdarg.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/select.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define MAX(a, b) a &lt; b ? b : a
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>used_for_cleanup_fd</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>panic</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>format</span><span class=p>,</span> <span class=p>...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>va_list</span> <span class=n>args</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>va_start</span><span class=p>(</span><span class=n>args</span><span class=p>,</span> <span class=n>format</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>vfprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=n>format</span><span class=p>,</span> <span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>va_end</span><span class=p>(</span><span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cleanup</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>used_for_cleanup_fd</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>used_for_cleanup_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>run_client</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>remote_address</span><span class=p>,</span> <span class=kt>int</span> <span class=n>remote_port</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>512</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>client_fd</span> <span class=o>=</span> <span class=nf>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>client_fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;socket() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>atexit</span><span class=p>(</span><span class=n>cleanup</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>used_for_cleanup_fd</span> <span class=o>=</span> <span class=n>client_fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>server_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>server_addr</span><span class=p>.</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>server_addr</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=nf>inet_addr</span><span class=p>(</span><span class=n>remote_address</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>server_addr</span><span class=p>.</span><span class=n>sin_port</span> <span class=o>=</span> <span class=nf>htons</span><span class=p>(</span><span class=n>remote_port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ret</span> <span class=o>=</span> <span class=nf>connect</span><span class=p>(</span><span class=n>client_fd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>server_addr</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                <span class=k>sizeof</span><span class=p>(</span><span class=n>server_addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;connect() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fgets</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>),</span> <span class=n>stdin</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span><span class=p>[</span><span class=nf>strcspn</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>buf_len</span> <span class=o>=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>buf_len</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>buf_len</span> <span class=o>&gt;=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;input too long</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=n>sent_bytes</span> <span class=o>=</span> <span class=nf>send</span><span class=p>(</span><span class=n>client_fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>buf_len</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sent_bytes</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;send() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=n>recv_bytes</span> <span class=o>=</span> <span class=nf>recv</span><span class=p>(</span><span class=n>client_fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>recv_bytes</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;recv() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>run_server</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>address</span><span class=p>,</span> <span class=kt>int</span> <span class=n>port</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>512</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>server_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>server_addr</span><span class=p>.</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>server_addr</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=nf>inet_addr</span><span class=p>(</span><span class=n>address</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>server_addr</span><span class=p>.</span><span class=n>sin_port</span> <span class=o>=</span> <span class=nf>htons</span><span class=p>(</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>server_fd</span> <span class=o>=</span> <span class=nf>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>server_fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;socket() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>atexit</span><span class=p>(</span><span class=n>cleanup</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>used_for_cleanup_fd</span> <span class=o>=</span> <span class=n>server_fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ret</span> <span class=o>=</span> <span class=nf>bind</span><span class=p>(</span><span class=n>server_fd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>server_addr</span><span class=p>),</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>server_addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;bind() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ret</span> <span class=o>=</span> <span class=nf>listen</span><span class=p>(</span><span class=n>server_fd</span><span class=p>,</span> <span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;listen() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>client_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>socklen_t</span> <span class=n>client_addr_len</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>client_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fd_set</span> <span class=n>fds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>FD_ZERO</span><span class=p>(</span><span class=o>&amp;</span><span class=n>fds</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>FD_SET</span><span class=p>(</span><span class=n>server_fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fds</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>max_fd</span> <span class=o>=</span> <span class=n>server_fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>fd_set</span> <span class=n>rfds</span> <span class=o>=</span> <span class=n>fds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>retval</span> <span class=o>=</span> <span class=nf>select</span><span class=p>(</span><span class=n>max_fd</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rfds</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;select() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>FD_ISSET</span><span class=p>(</span><span class=n>server_fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rfds</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// new connection
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=kt>int</span> <span class=n>client_fd</span> <span class=o>=</span> <span class=nf>accept</span><span class=p>(</span><span class=n>server_fd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>client_addr</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                             <span class=o>&amp;</span><span class=n>client_addr_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>client_fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;accept() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nf>FD_SET</span><span class=p>(</span><span class=n>client_fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fds</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>max_fd</span> <span class=o>=</span> <span class=nf>MAX</span><span class=p>(</span><span class=n>max_fd</span><span class=p>,</span> <span class=n>client_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>server_fd</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>fd</span> <span class=o>&lt;=</span> <span class=n>max_fd</span><span class=p>;</span> <span class=n>fd</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>FD_ISSET</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rfds</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>ssize_t</span> <span class=n>read_bytes</span> <span class=o>=</span> <span class=nf>recv</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>read_bytes</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;recv() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>read_bytes</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nf>FD_CLR</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fds</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=nf>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>ssize_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>read_bytes</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=p>)</span><span class=nf>toupper</span><span class=p>((</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=p>)</span><span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>ssize_t</span> <span class=n>sent_bytes</span> <span class=o>=</span> <span class=nf>send</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>read_bytes</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>sent_bytes</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;send() error: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;usage: &lt;mode&gt; &lt;IP&gt; &lt;port&gt;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>mode</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>address</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>port</span> <span class=o>=</span> <span class=nf>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>3</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>strncmp</span><span class=p>(</span><span class=n>mode</span><span class=p>,</span> <span class=s>&#34;client&#34;</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>run_client</span><span class=p>(</span><span class=n>address</span><span class=p>,</span> <span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>strncmp</span><span class=p>(</span><span class=n>mode</span><span class=p>,</span> <span class=s>&#34;server&#34;</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>run_server</span><span class=p>(</span><span class=n>address</span><span class=p>,</span> <span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div></article></main></div><footer class=footer><span class=footer_item></span>&nbsp;<div class=footer_social-icons><a href=https://github.com/ileonli target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=/index.xml target=_blank rel="noopener noreferrer me" title=Rss><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div><small class=footer_copyright>© 2025 Leon Li.
Powered by <a href=https://github.com/hugo-sid/hugo-blog-awesome target=_blank rel=noopener>Hugo blog awesome</a>.</small></footer><a href=# title=回到顶部 id=totop><svg width="48" height="48" fill="currentcolor" stroke="currentcolor" viewBox="0 96 960 960"><path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197z"/></svg>
</a><script src=https://ileonli.github.io/js/main.min.35f435a5d8eac613c52daa28d8af544a4512337d3e95236e4a4978417b8dcb2f.js integrity="sha256-NfQ1pdjqxhPFLaoo2K9USkUSM30+lSNuSkl4QXuNyy8="></script></body></html>