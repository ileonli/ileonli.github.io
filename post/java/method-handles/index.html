<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Java 方法句柄（翻译）</title>
<link href=https://unpkg.com/@master/normal.css rel=stylesheet><script src=https://unpkg.com/@master/style@1.5.0></script><script src=https://unpkg.com/@master/styles@1.13.0></script><script src=https://unpkg.com/master-styles-group></script><style>@font-face{font-family:sourcehanserifsc;src:url(/fonts/SourceHanSerifSC-Regular.otf)}html{font-family:sourcehanserifsc}</style></head><body class="bg:fade-84@dark font:fade-16@dark"><div class="d:flex flex:column@<=sm pt:60 px:24 jc:center gap:44 word-break:break-word"><div class="max-w:800 w:full box:content-box"><article class="box:border-box pt:32"><div class="_:where(a):hover{text-decoration-color:fade}
_:where(a){text-decoration:2;underline;fade-30;_text-decoration-color:fade-70@dark}
_:where(blockquote){bl:5;solid;fade-76/.1;_bl:5;solid;fade-34/.1@dark}
_:where(code){font:90%;_v:middle}
_:where(code:not(.highlight_*,pre_*)){p:2}
_:where(del){text-decoration:1;line-through;fade-68;_text-decoration-color:red-64@dark}
_:where(figcaption){text:14;_p:10;20;0;_width:fit;_mx:auto;_font:fade-56;_font:fade-57@dark}
_:where(h1,h2,h3,h4,h5,h6){mt:1em}
_:where(h1){font:40;_font:extrabold}
_:where(h1){my:1em}
_:where(h2){font:32}
_:where(h3){font:24}
_:where(h4){font:20}
_:where(h5){font:16}
_:where(h6){font:14}
_:where(li)::marker{font:fade-44;_font:fade-68@dark}
_:where(li){pl:.375em}
_:where(mark){text-decoration:1;underline;#fce016;_bg:transparent;_text-decoration-color:rgb(252;224;22/.5)@dark}
_:where(p,li){font:fade-76;_font:16;_line-height:1.65;_font:fade-34@dark}
_:where(p,pre,blockquote,figure,ul,ol,table){my:1em}
>:first-child{mt:0!}
_:where(pre){p:20;_r:8;_overflow:auto}
_:where(pre,code:not(.highlight_*)){bg:fade-2;_bg:fade-92!@dark}
_:where(strong,b,a,code:not(.highlight_*),mark,del){font:fade-92;_font:fade-12@dark}
_:where(table){width:full;_border-spacing:0}
_:where(td){v:baseline}
_:where(td,th):first-child{pl:0}
_:where(td,th):last-child{pr:0}
_:where(td,th){bb:1;solid;fade-92/.06;_p:6;_b:fade-4/.04@dark}
_:where(th){font:fade-78;_font:14;_text:left;_font:fade-12@dark}
_:where(th,p_code,li_code,a,mark){font:semibold;_font:medium@dark}
_:where(ul){list-style-type:disc}
_:where(ul,ol,blockquote){pl:1em}
_:where(video,img){max-width:full}
_:where(video){mx:auto}
_:where(img){mx:auto}
_:where(a,mark){text-underline-offset:3}
_:where(hr){h:2;_bg:fade-10;_bg:fade-70@dark;_my:1em}"><h1 id=java-方法句柄翻译>Java 方法句柄（翻译）</h1><blockquote><p>翻译自：<a href=https://dev.java/learn/introduction_to_method_handles/ target=_blank rel="noopener noreferrer">https://dev.java/learn/introduction_to_method_handles/</a></p></blockquote><h2 id=什么是方法句柄what-are-method-handles>什么是方法句柄（What are method handles）</h2><p>方法句柄是一种用于查找和调用方法的低级机制。与反射一样，方法句柄也提供了调用方法、调用构造函数以及访问字段的手段。</p><p>那么，方法句柄究竟什么是呢？它是对底层方法、构造函数或字段的可调用引用。方法句柄允许在一个简单的指向方法的引用之上进行一系列操作，这些操作包括插入或重新排列参数、转换返回值等。</p><p>让我们深入探讨一下方法句柄能够提供什么功能以及我们如何有效地使用它们。</p><h2 id=访问检查access-checking>访问检查（Access checking）</h2><p>方法句柄的访问检查与反射的执行方式是不同的。<strong>使用反射时</strong>，每次调用都会对调用者进行访问检查。<strong>而对于方法句柄</strong>，访问检查只在方法句柄创建时进行。</p><p>需要注意的是，如果在能够访问非公共成员的上下文中创建了方法句柄，那么当该方法句柄被传递到外部时，可以通过方法句柄访问非公共成员。</p><p>因此，非公共成员可能会被不应有访问权限的代码访问。开发者有责任将此类方法句柄限制在其创建的上下文内。另外，可以直接使用合适的查找对象来创建具有访问限制的方法句柄。</p><h2 id=方法句柄查找method-handle-lookup>方法句柄查找（Method handle lookup）</h2><p>要创建方法句柄，我们首先需要创建一个 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html target=_blank rel="noopener noreferrer"><code>LookUp</code></a> 对象，此为创建方法句柄的工厂。根据 <code>Lookup</code> 对象本身或方法句柄的使用方式，我们可以决定是否需要限制其访问级别。</p><p>例如，如果我们创建了一个指向私有方法的方法句柄，并且该方法句柄可以从外部访问，那么该私有方法也就可以被外部访问（译者注：现在，外部代码可以直接调用原本受保护的私有方法，从而破坏了方法的私有性）。</p><p>通常我们希望避免这种情况。<strong>一种办法</strong>是将 <code>Lookup</code> 对象和方法句柄设为私有。<strong>另一种方法</strong>是使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.html#publicLookup%28%29 target=_blank rel="noopener noreferrer"><code>MethodHandles.publicLookup</code></a> 方法创建 <code>Lookup</code> 对象，这样它只能查找公共类的公共成员（译者注：未导出的包，或受保护或私有的类和成员不会被搜索到）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandles.<span style=color:#a6e22e>Lookup</span> publicLookup <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>publicLookup</span>();
</span></span></code></pre></div><p>如果我们打算将 <code>Lookup</code> 对象和方法句柄设为私有，那么访问私有和受保护的成员是安全的（外部无法访问私有的方法句柄）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandles.<span style=color:#a6e22e>Lookup</span> lookup <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>lookup</span>();
</span></span></code></pre></div><h2 id=方法类型method-type>方法类型（Method type）</h2><p>要查找方法句柄，我们还需要提供方法或字段的类型信息。方法的类型信息通过 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodType.html target=_blank rel="noopener noreferrer"><code>MethodType</code></a> 类表示。为了实例化一个 <code>MethodType</code> 对象，需要提供函数返回类型作为第一个形参，后跟函数所有实参类型:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodType methodType <span style=color:#f92672>=</span> MethodType.<span style=color:#a6e22e>methodType</span>(<span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span> <span style=color:#75715e>/* the method returns integer */</span>,
</span></span><span style=display:flex><span>        String.<span style=color:#a6e22e>class</span> <span style=color:#75715e>/* and accepts a single String argument*/</span>);
</span></span></code></pre></div><p>有了 <code>Lookup</code> 和 <code>MethodType</code> 实例后，我们就可以查找方法句柄了。</p><ul><li><p>对于<strong>实例方法</strong>，我们应该使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findVirtual%28java.lang.Class,java.lang.String,java.lang.invoke.MethodType%29 target=_blank rel="noopener noreferrer"><code>Lookup.findVirtual</code></a>。</p></li><li><p>对于<strong>静态方法</strong>，我们应该使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findStatic%28java.lang.Class,java.lang.String,java.lang.invoke.MethodType%29 target=_blank rel="noopener noreferrer"><code>Lookup.findStatic</code></a>。</p></li></ul><p>这两种方法都接收以下参数：方法所在的 <code>Class</code>，表示方法名称的 <code>String</code>，以及一个 <code>MethodType</code>。</p><p>在下面的示例中，我们使用 <code>Lookup.findVirtual</code> 方法查找一个实例方法 <code>String.replace</code>，该方法接收两个 <code>char</code> 参数并返回一个 <code>String</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandles.<span style=color:#a6e22e>Lookup</span> lookup <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>lookup</span>();
</span></span><span style=display:flex><span>MethodType replaceMethodType <span style=color:#f92672>=</span> MethodType.<span style=color:#a6e22e>methodType</span>(String.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>char</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>char</span>.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>MethodHandle replaceMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findVirtual</span>(String.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;replace&#34;</span>, replaceMethodType);
</span></span></code></pre></div><p>在下一个示例中，我们使用 <code>Lookup.findStatic</code> 来查找一个静态方法 <code>String.valueOf</code>，该方法接收一个 <code>Object</code> 参数并返回一个 <code>String</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodType valueOfMethodType <span style=color:#f92672>=</span> MethodType.<span style=color:#a6e22e>methodType</span>(String.<span style=color:#a6e22e>class</span>, Object.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>MethodHandle valueOfMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(String.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;valueOf&#34;</span>, valueOfMethodType);
</span></span></code></pre></div><p>类似地，我们可以使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findConstructor%28java.lang.Class,java.lang.invoke.MethodType%29 target=_blank rel="noopener noreferrer"><code>Lookup.findConstructor</code></a> 方法来查找指向任何构造函数的方法句柄。</p><p>最后，当我们获得了一个方法句柄时，我们可以用此调用引用的方法。</p><h2 id=调用方法句柄method-handle-invocation>调用方法句柄（Method handle invocation）</h2><p>可以通过多种方式调用方法句柄引用的方法。</p><p>所有调用的方法最终都会汇集到一个方法上：<a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandle.html#invokeExact%28java.lang.Object...%29 target=_blank rel="noopener noreferrer"><code>MethodHandle.invokeExact</code></a>。正如方法名称所示，提供给 <code>invokeExact</code> 方法的参数必须严格匹配方法句柄的类型。</p><p>例如，如果我们调用 <code>String.replace</code> 方法，参数必须严格对应于：返回类型为 <code>String</code> 和两个 <code>char</code> 参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodType replaceMethodType <span style=color:#f92672>=</span> MethodType.<span style=color:#a6e22e>methodType</span>(String.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>char</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>char</span>.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>MethodHandle replaceMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findVirtual</span>(String.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;replace&#34;</span>, replaceMethodType);
</span></span><span style=display:flex><span>String result <span style=color:#f92672>=</span> (String) replaceMethodHandle.<span style=color:#a6e22e>invokeExact</span>(<span style=color:#e6db74>&#34;dummy&#34;</span>, <span style=color:#e6db74>&#39;d&#39;</span>, <span style=color:#e6db74>&#39;m&#39;</span>);
</span></span></code></pre></div><p><a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandle.html#invoke%28java.lang.Object...%29 target=_blank rel="noopener noreferrer"><code>MethodHandle.invoke</code></a> 更为宽松。它尝试获取一个具有调整类型的新方法句柄，使其严格匹配提供的参数的类型。然后，使用 <code>invokeExact</code> 调用已调整的方法句柄。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>String result <span style=color:#f92672>=</span> (String) replaceMethodHandle.<span style=color:#a6e22e>invoke</span>((Object)<span style=color:#e6db74>&#34;dummy&#34;</span>, (Object)<span style=color:#e6db74>&#39;d&#39;</span>, (Object)<span style=color:#e6db74>&#39;m&#39;</span>); <span style=color:#75715e>// would fail with `invokeExact`</span>
</span></span></code></pre></div><p>另一种调用方法句柄的替代方法是使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandle.html#invokeWithArguments%28java.lang.Object...%29 target=_blank rel="noopener noreferrer"><code>MethodHandle.invokeWithArguments</code></a>。这种方法调用的结果等同于 <code>invoke</code>，区别在于此方法允许你将所有参数打包成一个 <code>Object</code> 类型的数组或 <code>List</code>，然后传递给方法。。</p><p>该方法的一个有趣特性是，如果提供的参数数量超过了实际的数量，所有多出的参数将被压缩到最后一个参数中，并将其视为一个数组。</p><h2 id=访问属性accessing-fields>访问属性（Accessing fields）</h2><p>下边的代码示例演示了如何创建对字段的读取或写入的方法句柄：</p><ul><li><p>对于<strong>实例字段</strong>（Instance Fields），可以使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findGetter%28java.lang.Class,java.lang.String,java.lang.Class%29 target=_blank rel="noopener noreferrer"><code>findGetter</code></a> 和 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findSetter%28java.lang.Class,java.lang.String,java.lang.Class%29 target=_blank rel="noopener noreferrer"><code>findSetter</code></a> 方法。</p></li><li><p>对于<strong>静态字段</strong>（Static Fields），可以使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findStaticGetter%28java.lang.Class,java.lang.String,java.lang.Class%29 target=_blank rel="noopener noreferrer"><code>findStaticGetter</code></a> 和 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findStaticSetter%28java.lang.Class,java.lang.String,java.lang.Class%29 target=_blank rel="noopener noreferrer"><code>findStaticSetter</code></a> 方法。</p></li></ul><p>在创建访问属性的方法句柄时，不需要提供 <code>MethodType</code> 实例，需要提供字段的类型。</p><h3 id=静态字段>静态字段</h3><p>例如，假设我们在 <code>Example</code> 类中有一个静态字段 <code>magic</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> String magic <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;initial value static field&#34;</span>;
</span></span></code></pre></div><p>假设我们已经创建了一个 <code>Lookup</code> 对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MethodHandles.<span style=color:#a6e22e>Lookup</span> lookup <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>lookup</span>();
</span></span></code></pre></div><p>我们可以简单地创建 <code>setter</code> 和 <code>getter</code> 方法句柄，并分别调用它们：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MethodHandle setterStaticMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStaticSetter</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;magic&#34;</span>, String.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>MethodHandle getterStaticMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStaticGetter</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;magic&#34;</span>, String.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>setterStaticMethodHandle.<span style=color:#a6e22e>invoke</span>(<span style=color:#e6db74>&#34;new value static field&#34;</span>);
</span></span><span style=display:flex><span>String staticFieldResult <span style=color:#f92672>=</span> (String) getterStaticMethodHandle.<span style=color:#a6e22e>invoke</span>(); <span style=color:#75715e>// staticFieldResult == `new value static field`</span>
</span></span></code></pre></div><h3 id=实例字段>实例字段</h3><p>在 <code>Example</code> 类中有一个名为 <code>abc</code> 的实例字段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> String abc <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;initial value&#34;</span>;
</span></span></code></pre></div><p>类似地，我们可以为读取和写入实例字段创建方法句柄：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MethodHandle setterMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findSetter</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;abc&#34;</span>, String.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>MethodHandle getterMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findGetter</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;abc&#34;</span>, String.<span style=color:#a6e22e>class</span>);
</span></span></code></pre></div><p>要使用实例字段的 <code>setter</code> 和 <code>getter</code> 方法句柄，必须获取字段所属类的实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Example example <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Example();
</span></span></code></pre></div><p>然后，为我们的 <code>setter</code> 和 <code>getter</code> 的调用提供 <code>Example</code> 的实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>setterMethodHandle.<span style=color:#a6e22e>invoke</span>(example, <span style=color:#e6db74>&#34;new value&#34;</span>);
</span></span><span style=display:flex><span>String result <span style=color:#f92672>=</span> (String) getterMethodHandle.<span style=color:#a6e22e>invoke</span>(example); <span style=color:#75715e>// result == `new value`</span>
</span></span></code></pre></div><p>虽然可以使用方法句柄读取和写入字段值，但这并不常见。对于字段，更适合使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/VarHandle.html target=_blank rel="noopener noreferrer"><code>VarHandle</code></a>，可以使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findVarHandle%28java.lang.Class,java.lang.String,java.lang.Class%29 target=_blank rel="noopener noreferrer"><code>findVarHandle</code></a> 和 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findStaticVarHandle%28java.lang.Class,java.lang.String,java.lang.Class%29 target=_blank rel="noopener noreferrer"><code>findStaticVarHandle</code></a> 方法创建。</p><h2 id=处理数组working-with-arrays>处理数组（Working with arrays）</h2><p><a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.html target=_blank rel="noopener noreferrer"><code>MethodHandles</code></a> 类提供了一些预设方法句柄的方法。其中包括操作数组的方法句柄。创建这些方法句柄不需要访问检查，因此不需要 <code>Lookup</code> 对象。</p><p>我们使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.html#arrayConstructor%28java.lang.Class%29 target=_blank rel="noopener noreferrer"><code>arrayConstructor</code></a> 创建一个包含 5 个元素的 <code>String</code> 数组：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MethodHandle arrayConstructor <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>arrayConstructor</span>(String<span style=color:#f92672>[]</span>.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>String<span style=color:#f92672>[]</span> arr <span style=color:#f92672>=</span> (String<span style=color:#f92672>[]</span>) arrayConstructor.<span style=color:#a6e22e>invoke</span>(5);
</span></span></code></pre></div><p>要修改单个元素，我们可以使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.html#arrayElementSetter%28java.lang.Class%29 target=_blank rel="noopener noreferrer"><code>arrayElementSetter</code></a>，使用该方法需要提供要操作数组的引用、索引和新值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MethodHandle elementSetter <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>arrayElementSetter</span>(String<span style=color:#f92672>[]</span>.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>elementSetter.<span style=color:#a6e22e>invoke</span>(arr, 4, <span style=color:#e6db74>&#34;test&#34;</span>);
</span></span></code></pre></div><p>要读取单个元素的值，我们应该使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.html#arrayElementGetter%28java.lang.Class%29 target=_blank rel="noopener noreferrer"><code>arrayElementGetter</code></a> 方法句柄，需要提供目标数组和索引：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MethodHandle elementGetter <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>arrayElementGetter</span>(String<span style=color:#f92672>[]</span>.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>String element <span style=color:#f92672>=</span> (String) elementGetter.<span style=color:#a6e22e>invoke</span>(arr, 4); <span style=color:#75715e>// element == &#34;test&#34;</span>
</span></span></code></pre></div><p>还可以使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.html#arrayLength%28java.lang.Class%29 target=_blank rel="noopener noreferrer"><code>arrayLength</code></a> 提供的方法句柄获取数组的长度：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MethodHandle arrayLength <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>arrayLength</span>(String<span style=color:#f92672>[]</span>.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> length <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span>) arrayLength.<span style=color:#a6e22e>invoke</span>(arr); <span style=color:#75715e>// length == 5</span>
</span></span></code></pre></div><h2 id=异常处理exception-handling>异常处理（Exception handling）</h2><p><code>invokeExact</code> 和 <code>invoke</code> 都会抛出 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Throwable.html target=_blank rel="noopener noreferrer"><code>Throwable</code></a>，因此对底层方法可抛出的异常没有任何限制。调用方法句柄的方法必须明确抛出 <code>Throwable</code> 或捕获它。</p><p><code>MethodHandles</code> 中有一些方法可以使异常处理变得更加简单。让我们看几个示例。</p><h3 id=catch-wrapper><code>catch</code> wrapper</h3><p><a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.html#catchException%28java.lang.invoke.MethodHandle,java.lang.Class,java.lang.invoke.MethodHandle%29 target=_blank rel="noopener noreferrer"><code>MethodHandles.catchException</code></a> 方法可以将给定的方法句柄包装在提供的异常处理方法句柄中。</p><p>假设我们有一个执行某些业务逻辑的方法 <code>problematicMethod</code>，以及一个处理 <a href=https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/IllegalArgumentException.html target=_blank rel="noopener noreferrer"><code>IllegalArgumentException</code></a> 异常的方法 <code>exceptionHandler</code>。</p><p>异常处理程序方法必须返回与原始方法相同的类型。接收的<strong>第一个参数</strong>是我们感兴趣的 <code>Throwable</code> 类，<strong>第二个参数</strong>是原方法接收的参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>problematicMethod</span>(String argument) <span style=color:#66d9ef>throws</span> IllegalArgumentException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#34;invalid&#34;</span>.<span style=color:#a6e22e>equals</span>(argument)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> 1;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>exceptionHandler</span>(IllegalArgumentException e, String argument) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// log exception</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> 0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以查找这两个方法的方法句柄，并将 <code>problematicMethod</code> 包装在 <code>exceptionHandler</code> 内。<code>MethodHandle</code> 在调用时会正确处理 <code>IllegalArgumentException</code>，<strong>如果出现其他异常</strong>，则会继续抛出。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MethodHandles.<span style=color:#a6e22e>Lookup</span> lookup <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>lookup</span>();
</span></span><span style=display:flex><span>MethodHandle methodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;problematicMethod&#34;</span>, MethodType.<span style=color:#a6e22e>methodType</span>(<span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, String.<span style=color:#a6e22e>class</span>));
</span></span><span style=display:flex><span>MethodHandle handler <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;exceptionHandler&#34;</span>,
</span></span><span style=display:flex><span>        MethodType.<span style=color:#a6e22e>methodType</span>(<span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, IllegalArgumentException.<span style=color:#a6e22e>class</span>, String.<span style=color:#a6e22e>class</span>));
</span></span><span style=display:flex><span>MethodHandle wrapped <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>catchException</span>(methodHandle, IllegalArgumentException.<span style=color:#a6e22e>class</span>, handler);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(wrapped.<span style=color:#a6e22e>invoke</span>(<span style=color:#e6db74>&#34;valid&#34;</span>)); <span style=color:#75715e>// outputs &#34;1&#34;</span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(wrapped.<span style=color:#a6e22e>invoke</span>(<span style=color:#e6db74>&#34;invalid&#34;</span>)); <span style=color:#75715e>// outputs &#34;0&#34;</span>
</span></span></code></pre></div><h3 id=finally-wrapper><code>finally</code> wrapper</h3><p><a href=https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/invoke/MethodHandles.html#tryFinally%28java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle%29 target=_blank rel="noopener noreferrer"><code>MethodHandles.tryFinally</code></a> 方法的工作方式与 <code>catch</code> wrapper 类似，但它不是一个异常处理程序，而是在目标方法周围添加了一个 <code>try-finally</code> 块。</p><p>假设我们有一个包含清理逻辑的方法 <code>cleanupMethod</code>。该方法的返回类型必须与被包装的目标方法返回类型相同。此外，方法参数需要接收一个 <code>Throwable</code>，然后是来自目标方法的结果值，然后是所有参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>cleanupMethod</span>(Throwable e, <span style=color:#66d9ef>int</span> result, String argument) {
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;inside finally block&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以将前面示例中的方法句柄包装在 <code>try-finally</code> 块中，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MethodHandle cleanupMethod <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;cleanupMethod&#34;</span>,
</span></span><span style=display:flex><span>        MethodType.<span style=color:#a6e22e>methodType</span>(<span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, Throwable.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, String.<span style=color:#a6e22e>class</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MethodHandle wrappedWithFinally <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>tryFinally</span>(methodHandle, cleanupMethod);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(wrappedWithFinally.<span style=color:#a6e22e>invoke</span>(<span style=color:#e6db74>&#34;valid&#34;</span>)); <span style=color:#75715e>// outputs &#34;inside finally block&#34; and &#34;1&#34;</span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(wrappedWithFinally.<span style=color:#a6e22e>invoke</span>(<span style=color:#e6db74>&#34;invalid&#34;</span>)); <span style=color:#75715e>// outputs &#34;inside finally block&#34; and throws java.lang.IllegalArgumentException </span>
</span></span></code></pre></div><h2 id=方法句柄转换method-handle-transformations>方法句柄转换（Method handle transformations）</h2><p>正如前面的例子所示，方法句柄可以进行封装，封装后会拥有比指向底层方法更多的行为。</p><p>我们可以获取<strong>适配器</strong>方法句柄，包装目标方法句柄以添加某些行为，如：参数重排序、预先插入或过滤返回值。</p><h3 id=类型转换>类型转换</h3><p>方法句柄的类型可以使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandle.html#asType%28java.lang.invoke.MethodType%29 target=_blank rel="noopener noreferrer"><code>asType</code></a> 方法转换为新类型。如果不可能转换为此类型，将收到 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/WrongMethodTypeException.html target=_blank rel="noopener noreferrer"><code>WrongMethodTypeException</code></a> 异常。</p><p>请记住，当我们应用转换时，实际上我们有两个方法句柄，其中原始的方法句柄被封装在一些额外的逻辑中。在这种情况下，封装器会接收参数，并尝试将它们转换为与原始方法句柄的参数相匹配的类型。一旦原始方法句柄完成其工作并返回结果，封装器将尝试将这个结果转换为指定的类型。</p><p>假设我们有一个 <code>test</code> 方法，接收一个 <code>Object</code> 并返回一个 <code>String</code>。我们可以将这样一个方法适应为接收更具体的参数类型，如 <code>String</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandle targetMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;test&#34;</span>, 
</span></span><span style=display:flex><span>        MethodType.<span style=color:#a6e22e>methodType</span>(String.<span style=color:#a6e22e>class</span>, Object.<span style=color:#a6e22e>class</span>));
</span></span><span style=display:flex><span>MethodHandle adapter <span style=color:#f92672>=</span> targetMethodHandle.<span style=color:#a6e22e>asType</span>(
</span></span><span style=display:flex><span>        MethodType.<span style=color:#a6e22e>methodType</span>(String.<span style=color:#a6e22e>class</span>, String.<span style=color:#a6e22e>class</span>));
</span></span><span style=display:flex><span>String originalResult <span style=color:#f92672>=</span> (String) targetMethodHandle.<span style=color:#a6e22e>invoke</span>(111); <span style=color:#75715e>// works</span>
</span></span><span style=display:flex><span>String adapterResult <span style=color:#f92672>=</span> (String) adapter.<span style=color:#a6e22e>invoke</span>(<span style=color:#e6db74>&#34;aaaaaa&#34;</span>); <span style=color:#75715e>// works</span>
</span></span><span style=display:flex><span>adapterResult <span style=color:#f92672>=</span> (String) adapter.<span style=color:#a6e22e>invoke</span>(111); <span style=color:#75715e>// fails</span>
</span></span></code></pre></div><p>事实上，每次我们在 <code>MethodHandle</code> 上调用 <code>invoke</code> 时，首先发生的是一次 <code>asType</code> 调用。<code>invoke</code> 接收并返回对象，然后尝试将这些对象转换为更具体的类型。这些具体的类型来自我们的代码，即我们作为参数传递的确切值和我们将返回值转换成的类型。一旦类型成功转换，就会调用 <code>invokeExact</code> 方法来处理这些具体类型。</p><h3 id=重新排列参数>重新排列参数</h3><p>要获取一个带有重新排列参数的适配器方法句柄，我们可以使用 <a href=https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/invoke/MethodHandles.html#permuteArguments%28java.lang.invoke.MethodHandle,java.lang.invoke.MethodType,int...%29 target=_blank rel="noopener noreferrer"><code>MethodHandles.permuteArguments</code></a>。</p><p>首先，我们有一个接受不同类型参数的 <code>test</code> 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test</span>(<span style=color:#66d9ef>int</span> v1, String v2, <span style=color:#66d9ef>long</span> v3, <span style=color:#66d9ef>boolean</span> v4) {
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(v1 <span style=color:#f92672>+</span> v2 <span style=color:#f92672>+</span> v3 <span style=color:#f92672>+</span> v4);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>查找一个指向 <code>test</code> 方法的方法句柄：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandle targetMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;test&#34;</span>,
</span></span><span style=display:flex><span>        MethodType.<span style=color:#a6e22e>methodType</span>(<span style=color:#66d9ef>void</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, String.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>long</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>boolean</span>.<span style=color:#a6e22e>class</span>));
</span></span></code></pre></div><p><code>permuteArguments</code> 方法会接收下边参数：</p><ul><li>目标方法句柄，在我们的例子中指向 <code>test</code> 方法。</li><li>新的 <code>MethodType</code>，其中所有参数以所需的方式重新排序。</li><li>一个指定参数新顺序的索引数组。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandle reversedArguments <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>permuteArguments</span>(targetMethodHandle,
</span></span><span style=display:flex><span>        MethodType.<span style=color:#a6e22e>methodType</span>(<span style=color:#66d9ef>void</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>boolean</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>long</span>.<span style=color:#a6e22e>class</span>, String.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>), 3, 2, 1, 0);
</span></span><span style=display:flex><span>reversedArguments.<span style=color:#a6e22e>invoke</span>(<span style=color:#66d9ef>false</span>, 1L, <span style=color:#e6db74>&#34;str&#34;</span>, 123); <span style=color:#75715e>// outputs: &#34;123str1false&#34;</span>
</span></span></code></pre></div><h3 id=插入参数>插入参数</h3><p><a href=https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/invoke/MethodHandles.html#insertArguments%28java.lang.invoke.MethodHandle,int,java.lang.Object...%29 target=_blank rel="noopener noreferrer"><code>MethodHandles.insertArguments</code></a> 方法提供了一个带有一个或多个绑定参数的 <code>MethodHandle</code>。</p><p>例如，让我们再次查看前面示例中的方法句柄：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandle targetMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;test&#34;</span>,
</span></span><span style=display:flex><span>        MethodType.<span style=color:#a6e22e>methodType</span>(<span style=color:#66d9ef>void</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, String.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>long</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>boolean</span>.<span style=color:#a6e22e>class</span>));
</span></span></code></pre></div><p>我们可以轻松地获取一个预先带有 <code>String</code> 和 <code>long</code> 参数绑定的适配器 <code>MethodHandle</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandle boundArguments <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>insertArguments</span>(targetMethodHandle, 1, <span style=color:#e6db74>&#34;new&#34;</span>, 3L);
</span></span></code></pre></div><p>要调用生成的方法句柄，我们只需要提供未预先填充的参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>boundArguments.<span style=color:#a6e22e>invoke</span>(1, <span style=color:#66d9ef>true</span>); <span style=color:#75715e>// outputs: &#34;1new3true&#34;</span>
</span></span></code></pre></div><p>如果我们尝试传递已经预填充的参数，此方法会抛出 <code>WrongMethodTypeException</code> 异常。</p><h3 id=过滤参数>过滤参数</h3><p>我们可以使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.html#filterArguments%28java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle...%29 target=_blank rel="noopener noreferrer"><code>MethodHandles.filterArguments</code></a> 在调用目标方法句柄之前对参数进行转换。</p><p>为使用此方法，我们需要提供一下参数：</p><ul><li>目标方法句柄。</li><li>要转换的第一个参数的位置。</li><li>用于每个参数转换的方法句柄。</li></ul><p>如果某些参数不需要转换，可以传递 <code>null</code> 跳过。如果我们只需要转换其中的一部分参数，也可以完全跳过其余参数。</p><p>让我们重用上一节中的方法句柄，并在调用之前过滤其中的一些参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandle targetMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;test&#34;</span>,
</span></span><span style=display:flex><span>        MethodType.<span style=color:#a6e22e>methodType</span>(<span style=color:#66d9ef>void</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, String.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>long</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>boolean</span>.<span style=color:#a6e22e>class</span>));
</span></span></code></pre></div><p>然后我们创建一个方法，通过对 <code>original</code> 取反进行转换：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>negate</span>(<span style=color:#66d9ef>boolean</span> original) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span>original;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>额外构造一个方法，通过增加给定的整数值进行转换：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>increment</span>(<span style=color:#66d9ef>int</span> original) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>++</span>original;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以为这些转换方法获取方法句柄：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandle negate <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;negate&#34;</span>, MethodType.<span style=color:#a6e22e>methodType</span>(<span style=color:#66d9ef>boolean</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>boolean</span>.<span style=color:#a6e22e>class</span>));
</span></span><span style=display:flex><span>MethodHandle increment <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;increment&#34;</span>, MethodType.<span style=color:#a6e22e>methodType</span>(<span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>));
</span></span></code></pre></div><p>使用它们来获得一个可以进行参数过滤的方法句柄：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#75715e>// applies filter &#39;increment&#39; to argument at index 0, &#39;negate&#39; to the last argument, </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// and passes the result to &#39;targetMethodHandle&#39;</span>
</span></span><span style=display:flex><span>MethodHandle withFilters <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>filterArguments</span>(targetMethodHandle, 0, increment, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, negate);
</span></span><span style=display:flex><span>withFilters.<span style=color:#a6e22e>invoke</span>(3, <span style=color:#e6db74>&#34;abc&#34;</span>, 5L, <span style=color:#66d9ef>false</span>); <span style=color:#75715e>// outputs &#34;4abc5true&#34;</span>
</span></span></code></pre></div><h3 id=折叠参数>折叠参数</h3><p>当我们想要在调用 <code>MethodHandle</code> 之前对一个或多个参数进行预处理时，我们可以使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.html#foldArguments%28java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle%29 target=_blank rel="noopener noreferrer"><code>MethodHandles.foldArguments</code></a>，并提供一个组合方法的方法句柄，该方法将接受从任意首选位置开始的参数。</p><p>假设我们有一个 <code>target</code> 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>target</span>(<span style=color:#66d9ef>int</span> ignored, <span style=color:#66d9ef>int</span> sum, <span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d + %d equals %d and %d is ignored%n&#34;</span>, a, b, sum, ignored);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 <code>foldArguments</code>，我们可以预处理其参数的一个子集，并将结果值插入为另一个参数，然后继续执行 <code>target</code> 方法。</p><p>在我们的示例中，我们有参数 <code>int a，int b</code> 在最后。我们可以预处理任意数量的参数，但它们都必须在最后。假设我们想要计算 <code>a</code> 和 <code>b</code> 这两个值的和，因此让我们创建一个用于此目的的方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>结果值将被插入到目标方法中的一个参数。它必须是我们将要折叠的参数之前的参数，所以在我们的示例中是参数 <code>int sum</code>。</p><p>用于折叠结果的参数不能位于其他位置。如果目标方法需要接受与此折叠逻辑无关的更多参数，则它们必须全部放在最前面。</p><p>让我们创建方法句柄并看看如何将它们组合在一起：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandle targetMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;target&#34;</span>,
</span></span><span style=display:flex><span>        MethodType.<span style=color:#a6e22e>methodType</span>(<span style=color:#66d9ef>void</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>));
</span></span><span style=display:flex><span>MethodHandle combinerMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;sum&#34;</span>,
</span></span><span style=display:flex><span>        MethodType.<span style=color:#a6e22e>methodType</span>(<span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>));
</span></span><span style=display:flex><span>MethodHandle preProcessedArguments <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>foldArguments</span>(targetMethodHandle, 1, combinerMethodHandle);
</span></span></code></pre></div><p><code>foldArguments</code> 方法接受：</p><ul><li><code>MethodHandle target</code>: 目标方法的句柄，在我们的例子中为指向 <code>target</code> 方法的句柄。</li><li><code>int pos</code>: 一个整数，指定折叠相关的参数的起始位置。在我们的例子中，<code>sum</code> 参数位于位置 1，因此我们传递了 1。如果跳过此参数，<code>pos</code> 将默认为 0。</li><li><code>MethodHandle combiner</code>: 组合方法句柄，在我们的例子中为指向 <code>sum</code> 方法的句柄。</li></ul><p>最后，我们可以调用生成的方法句柄，并传递除 <code>sum</code> 之外的所有参数，<code>sum</code> 将被预先计算：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>preProcessedArguments.<span style=color:#a6e22e>invokeExact</span>(10000, 1, 2); <span style=color:#75715e>// outputs: &#34;1 + 2 equals 3 and 10000 is ignored&#34;</span>
</span></span></code></pre></div><p>有可能组合方法处理值但不返回任何内容。在这种情况下，目标方法参数列表中不需要结果占位符。</p><h3 id=过滤返回值>过滤返回值</h3><p>与参数类似，我们可以使用一个适配器来对返回值进行转换。</p><p>假设我们有一个返回 <code>String</code> 的方法，并且我们想将该方法返回的任何值传递到另一个方法中，该方法将字符 <code>d</code> 替换为 <code>m</code> 并将结果值大写。</p><p>这是 <code>getSomeString</code> 方法的方法句柄，它始终返回值 <code>"dummy"</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandle getSomeString <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;getSomeString&#34;</span>, MethodType.<span style=color:#a6e22e>methodType</span>(String.<span style=color:#a6e22e>class</span>));
</span></span></code></pre></div><p>这是执行转换的 <code>resultTransform</code> 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>resultTransform</span>(String value) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> value.<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#39;d&#39;</span>, <span style=color:#e6db74>&#39;m&#39;</span>).<span style=color:#a6e22e>toUpperCase</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是指向转换方法的方法句柄：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandle resultTransform <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>findStatic</span>(Example.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;resultTransform&#34;</span>, MethodType.<span style=color:#a6e22e>methodType</span>(String.<span style=color:#a6e22e>class</span>, String.<span style=color:#a6e22e>class</span>));
</span></span></code></pre></div><p>最后，这是两个方法句柄的组合，其中由 <code>getSomeString</code> 方法返回的结果提供给 <code>resultTransform</code> 方法并相应地进行修改：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandle getSomeUppercaseString <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>filterReturnValue</span>(getSomeString, resultTransform);
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(getSomeUppercaseString.<span style=color:#a6e22e>invoke</span>()); <span style=color:#75715e>// outputs: &#34;MUMMY&#34;</span>
</span></span></code></pre></div><h2 id=方法句柄与反射method-handles-vs-reflection-api>方法句柄与反射（Method Handles vs Reflection API）</h2><p>方法句柄是在 JDK7 中引入的，作为协助编译器和语言运行时开发人员的工具。它们从未旨在取代反射。</p><p><a href=https://dev.java/learn/introduction_to_java_reflection/ target=_blank rel="noopener noreferrer">反射</a> 提供了一些方法句柄无法做到的功能，即列出类成员并检查它们的属性。另一方面，方法句柄可以以反射无法实现的方式进行转换和操作。</p><p>当涉及方法调用时，与访问检查和安全性有关的差异为：</p><ul><li><strong>反射</strong>：在每次调用时会对每个调用者都执行访问检查。</li><li><strong>方法句柄</strong>：仅在构建过程中进行访问检查。</li></ul><p>上边的差异使得通过方法句柄调用比反射更快。然而，必须采取某些预防措施，以确保方法句柄不被传递到不应访问的代码中。</p><p>您可以在 <a href=https://dev.java/learn/introduction_to_java_reflection/ target=_blank rel="noopener noreferrer">本教程</a> 中了解更多关于反射的信息。</p><h2 id=反射和方法句柄之间的转换conversion-between-reflection-api-and-method-handles>反射和方法句柄之间的转换（Conversion between Reflection API and method handles）</h2><p><code>Lookup</code> 对象可以用于将反射对象转换为行为上等效的方法句柄，从而提供对底层类成员更直接和高效的访问。</p><p>要创建指向给定 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/reflect/Method.html target=_blank rel="noopener noreferrer"><code>Method</code></a> 的方法句柄（假设查找类具有执行此操作的权限），可以使用 <code>unreflect</code>。</p><p>假设我们在 <code>Example</code> 类中有一个接受 <code>String</code> 参数并返回 <code>String</code> 的测试方法。使用反射，我们可以获得一个 <code>Method</code> 对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>Method method <span style=color:#f92672>=</span> Example.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getMethod</span>(<span style=color:#e6db74>&#34;test&#34;</span>, String.<span style=color:#a6e22e>class</span>);
</span></span></code></pre></div><p>借助于 <code>Lookup</code> 对象的帮助，我们可以使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#unreflect%28java.lang.reflect.Method%29 target=_blank rel="noopener noreferrer"><code>unreflect</code></a> 方法传入 <code>Method</code> 对象以获取 <code>MethodHandle</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>MethodHandles.<span style=color:#a6e22e>Lookup</span> lookup <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>lookup</span>();
</span></span><span style=display:flex><span>MethodHandle methodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>unreflect</span>(method);
</span></span><span style=display:flex><span>String result <span style=color:#f92672>=</span> (String) methodHandle.<span style=color:#a6e22e>invoke</span>(<span style=color:#e6db74>&#34;something&#34;</span>);
</span></span></code></pre></div><p>类似地，给定一个 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/reflect/Field.html target=_blank rel="noopener noreferrer"><code>Field</code></a> 对象，我们可以获得 <code>getter</code> 和 <code>setter</code> 方法句柄：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>Field field <span style=color:#f92672>=</span> Example.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getField</span>(<span style=color:#e6db74>&#34;magic&#34;</span>);
</span></span><span style=display:flex><span>MethodHandle setterMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>unreflectSetter</span>(field);
</span></span><span style=display:flex><span>MethodHandle getterMethodHandle <span style=color:#f92672>=</span> lookup.<span style=color:#a6e22e>unreflectGetter</span>(field);
</span></span><span style=display:flex><span>setterMethodHandle.<span style=color:#a6e22e>invoke</span>(<span style=color:#e6db74>&#34;something&#34;</span>);
</span></span><span style=display:flex><span>String result <span style=color:#f92672>=</span> (String) getterMethodHandle.<span style=color:#a6e22e>invoke</span>(); <span style=color:#75715e>// result == &#34;something&#34;</span>
</span></span></code></pre></div><p>还可以将 <code>MethodHandle</code> 转换为 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/reflect/Member.html target=_blank rel="noopener noreferrer"><code>Member</code></a>，前提是没有对给定的 <code>MethodHandle</code> 执行任何转换。</p><hr><p>假设我们有一个直接指向方法的方法句柄。我们可以使用 <a href=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.html#reflectAs%28java.lang.Class,java.lang.invoke.MethodHandle%29 target=_blank rel="noopener noreferrer"><code>MethodHandles.reflectAs</code></a> 方法获取 <code>Method</code> 对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>Method method <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>reflectAs</span>(Method.<span style=color:#a6e22e>class</span>, methodHandle);
</span></span></code></pre></div><p>对于 <code>Field</code> 对象也是类似的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>Field field <span style=color:#f92672>=</span> MethodHandles.<span style=color:#a6e22e>reflectAs</span>(Field.<span style=color:#a6e22e>class</span>, getterMethodHandle); <span style=color:#75715e>// same result is achieved by reflecting `setterMethodHandle`</span>
</span></span></code></pre></div><h2 id=结论conclusion>结论（Conclusion）</h2><p>在本教程中，我们深入了解了方法句柄机制，学会了如何高效地使用它。我们现在知道，方法句柄提供了一种高效调用方法的方式，但这种机制并不旨在取代反射。</p><p>由于方法句柄采用不同的访问检查方法，方法句柄在方法调用方面具有性能优势。然而，由于访问仅在方法句柄创建时进行检查，因此传递方法句柄应格外谨慎。</p><p>与反射不同，方法句柄不提供列出类成员和检查其属性的工具。另一方面，方法句柄允许我们将指向方法和字段的指针包装成更复杂的逻辑，如：参数和返回值的操作。</p></div></article></div></div></body><footer class="flex jc:center my:24"><div>Copyright © 2024, Leon Li.</div></footer></html>